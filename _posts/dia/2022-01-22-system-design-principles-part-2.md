---
layout: single
title: "데이터 중심 애플리케이션 설계 2장: 데이터 모델 & 질의 언어 패러다임 비교"
excerpt: "Designing Data-Intensive Applications by Martin Kleppmann"
categories: diapp
tags: [애플리케이션, 스키마, 맵리듀스, 데이터 모델, 트랜잭션, 일괄 처리]
toc: true
toc_sticky: true
sidebar_main: false

last_modified_at: 2022-03-29
---

<img align='right' width='200' height='200' src='https://user-images.githubusercontent.com/78655692/150554021-0a13844c-6b41-470c-870a-a41726ea3c84.png
'>
본 글은 Designing Data-Intensive Applications 책의 내용을 개인 공부 목적을 위한 요약 및 정리한 내용입니다. <br> 번역보다는 직역을 통해 영문책을 이해하려다 보니 단어나 문장이 다소 어색할 수 있습니다. <br>  영어문장에 맞게 최대한 이해하려 했습니다. 가지치기($\nearrow$)로 꾸며주는 말을 따로 빼서 육하원칙, 지칭 등을 넣어 해석했습니다.
<br> 이 시리즈는 지속적으로 업데이트할 예정입니다. 먼저 한글책을 빠르게 보고, 영문책을 통해 심도있게 내용을 보완할 것입니다. 처음은 엉망일지라도 끝은 완벽할 것입니다.<br>오타나 오류는 알려주시길 바라며, 도움이 되길 바랍니다.
{: .notice--info}

<br>
<br>
<br>
<br>

## Data Models and Query Languages

- 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생갹해야 하는지도 고려해봐야 한다.
- 대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다.
  - 다음 하위 계층 관점에서 데이터 모델을 표현하는 방법이 각 계층의 핵심적인 문제이다.
- 각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다.

<br>
<br>

### Relational Model Versus Document Model

- 오늘날 가장 잘 알려진 데이터 모델은 관계형 모델을 기반으로 한 SQL이다.
- 관계형 데이터베이스의 근원은 비즈니스 데이터 처리에 있다. (1960 ~ 1970)
  - **트랜잭션 처리** : 영업이나 은행 거래, 항공 예약, 창고에 재고 보관
  - **일괄 처리** : 고객 송장 작성, 급여 지불, 보고
- 관계형 모델의 목표는 정리된 인터페이스 뒤로 구현 세부 사항을 숨기는 것이다.
- 1970 ~ 1980에는 네트워크 모델과 계층 모델이 주요 대안이었지만, 관계형 모델이 우위를 차지함
- 오늘날 웹에서 볼 수 있는 대부분의 서비스도 관계형 데이터베이스를 통해 제공된다.

<br>
<br>

### The Birth of NoSQL

- NoSQL 데이터베이스를 채택한 다양한 이유
  1. 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
  2. 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
  3. 관계형 모델에서 지원하지 않는 특수 질의 동작
  4. 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람
- **다중 저장소 지속성 (polyglot persistence)** : 관계형 데이터베이스 + 비관계형 데이터스토어

<br>
<br>

### The Object-Relational Mismatch

- 대부분의 애플리케이션은 객체지향 프로그래밍 언어로 개발한다. 하지만 데이터를 관계형 테이블에 저장하기 위해선 애플리케이션 코드와 데이터 베이스 모델 객체 사이에서 전환 계층이 필요하다.
  - 이런 모델 사이의 분리를 **임피던스 불일치 (impedance mismatch)**라 한다.

<img src='https://user-images.githubusercontent.com/78655692/150621893-e7bf9110-f14e-48da-bc02-eb17b3d426cf.png' width=600>

<br>

- 이력서 같은 데이터 구조는 모든 내용을 갖추고 있는 문서라서 JSON 표현에 매우 적합하다.
- `user_id`를 통해 프로필을 식별하는 것은 **일대다 관계(one-to-many)** 관계다.

<img src='https://user-images.githubusercontent.com/78655692/150623016-94013f56-42b8-4d4c-82ce-ab44f52a916d.png' width=500>

<br>

- **다대일 관계 (many-to-one)**의 예시로 많은 사람들은 한 특정 지역에 살고 많은 사람들은 한 특정 업계에서 일한다.
- **다대다 관계 (many-to-many)**로 추천서가 있다.

<img src='https://user-images.githubusercontent.com/78655692/150623029-dc0a7e9a-46a1-4e4c-9894-01307ff66830.png' width=500>

<br>
<br>

### The relational model

- 관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것이다.
  - 관계는 튜플(로우)의 컬렉션
- 관계형 데이터베이스에서 **질의 최적화기 (query optimizer)**는 질의의 어느 부분을 어떤 순서로 실행할지를 결정하고 사용할 색인을 자동으로 결정한다.
- 새로운 방식으로 데이터에 질의하고 싶은 경우 새로운 색인을 선언하기만 하면 질의는 자동으로 가장 적합한 색인을 사용한다.

<br>
<br>

### Relational Versus Document Databases Today

- `문서 데이터 모델`을 선호하는 이유로, 스키마 유연성, 지역성에 기인한 더 나은 성능 때문. 또한 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 가깝기 때문
- `관계형 모델`을 선호하는 이유는, 조인, 다대일, 다대다 관계를 더 잘 지원

<br>
<br>

### Schema flexibility in the document model

- `JSON`은 문서의 데이터에 어떤 스키마를 강요하지 않는다.
- 관계형 데이터베이스에서 제공하는 `XML`은 선택적으로 스키마 유효성 검사를 포함할 수 있다.
  - 스키마 X = 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미
- **쓰기 스키마 (schema-on-write)** : 관계형 데이터베이스의 전통적인 접근 방식으로 스키마는 명시적이고 데이터 베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장한다. (**정적**(런타임) 타입 확인)
- **읽기 스키마 (schema-on-read)** : 데이터 구조는 암묵적이고 데이터를 읽을 때만 해석된다. (**동적**(런타임) 타입 확인)

<br>
<br>

### Data locality for queries

- **문서**는 보통 JSON, XML로 부호화된 단일 연속 문자열이나 JSON 또는 XML의 이진 변형으로 저장된다.
- **지역성**의 이점으로 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용된다.

<br>
<br>

### MapReduce Querying

- **맵리듀스 (MapReduce)**는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델
  - 이 메커니즘은 많은 문서를 대상으로 읽기 전용(read-only) 질의를 수행할 때 사용한다.