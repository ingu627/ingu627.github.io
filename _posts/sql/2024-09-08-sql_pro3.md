---
layout: single
title: '[MySQL] SQL 문법 및 예제 정리 - 서브쿼리, 윈도우 함수'
excerpt: "실무 적용 및 SQL 코테를 위한 자료입니다."
categories: SQL
tag : [서브 쿼리, 실무, 정리, mysql, 문법, 기초, 란, 설명, 코딩테스트, 코테]
toc: true
toc_sticky: true
sidebar_main: true

date: 2024-09-08
last_modified_at: 2024-09-08
---

<br>

## 서브쿼리(Subquery)

- 서브쿼리(Subquery)는 **쿼리 내에 포함된 또 다른 쿼리**를 의미합니다. 이는 하나의 SQL 문장 안에서, 다른 쿼리의 결과를 참조하거나 사용하기 위해 작성됩니다. 서브쿼리는 일반적으로 `SELECT`, `INSERT`, `UPDATE`, `DELETE` 문에서 사용되며, 주 쿼리(Main Query)에 필요한 데이터를 제공하는 역할을 합니다.
- **서브쿼리의 특징**

  1. **위치**: 서브쿼리는 주로 `SELECT`, `FROM`, `WHERE`, `HAVING` 절 내에서 사용됩니다.
  2. **독립성**: 서브쿼리는 독립적인 SQL 문장으로 실행될 수 있습니다. 하지만 주 쿼리와 결합될 때, 특정 조건을 만족하는 데이터만 반환합니다.
  3. **중첩 구조**: 주 쿼리 안에 중첩된 형태로 존재하며, 주 쿼리의 일부로 사용됩니다.

- 서브쿼리의 활용
  - **필터링**: 주 쿼리에서 반환할 데이터를 특정하기 위해 서브쿼리에서 데이터를 필터링합니다.
  - **계산**: 주 쿼리에서 직접 계산하기 어려운 값을 서브쿼리에서 계산하여 반환합니다.
  - **데이터 추출**: 주 쿼리에서 필요한 데이터를 서브쿼리를 통해 가져옵니다.

<br>

### 서브쿼리의 종류

1. **단일 행 서브쿼리**
   - 하나의 결과만 반환하는 서브쿼리
   
     ```sql
     # 예: 특정 부서의 최대 급여를 찾을 때
     SELECT employee_name 
     FROM Employees 
     WHERE salary = (SELECT MAX(salary) FROM Employees WHERE department_id = 1);
     ```

<br>

2. **다중 행 서브쿼리**
   - 여러 행의 결과를 반환하는 서브쿼리
     ```sql
     # 특정 부서에 속한 모든 직원의 이름을 찾을 때
     SELECT employee_name 
     FROM Employees 
     WHERE department_id IN (SELECT department_id FROM Departments WHERE location = 'New York');
     ```

<br>

3. **다중 열 서브쿼리**
   - 여러 열을 반환하는 서브쿼리
     ```sql
     # 특정 부서의 최대 급여와 해당 부서 ID를 찾을 때
     SELECT employee_name 
     FROM Employees 
     WHERE (department_id, salary) = (SELECT department_id, MAX(salary) FROM Employees GROUP BY department_id);
     ```

<br>

4. **상관 서브쿼리**
   - 주 쿼리의 각 행에 대해 서브쿼리가 실행되는 형태
     ```sql
     # 각 직원의 급여가 그 직원이 속한 부서의 평균 급여보다 높은지 확인할 때
     SELECT employee_name 
     FROM Employees e 
     WHERE salary > (SELECT AVG(salary) FROM Employees WHERE department_id = e.department_id);
     ```

<br>

## 윈도우 함수(Window Function)

- 윈도우 함수는 SQL에서 **특정 행 집합(윈도우)**에 대해 계산을 수행하는 함수입니다. 
- 일반적인 집계 함수와 달리, **윈도우 함수는 각 행에 대해 계산된 결과를 반환하면서도 원본 행을 유지**합니다. 즉, 데이터를 그룹화하지 않고도 그룹 내에서 누적 합계, 순위, 이동 평균 등을 계산할 수 있습니다.

> **윈도우 함수**는 그룹화 없이도 특정 집합 내에서 계산을 수행할 수 있는 강력한 도구입니다.

<br>

### 윈도우 함수의 기본 문법

```sql
SELECT column_name,
       window_function() OVER (PARTITION BY column1 ORDER BY column2)
FROM table_name;
```

- **`window_function()`**: 적용할 윈도우 함수 (예: `ROW_NUMBER()`, `RANK()`, `SUM()` 등)
- **`OVER`**: 윈도우 함수를 적용할 집합을 정의하는 절
- **`PARTITION BY`**: 데이터의 그룹을 정의. (이 부분은 선택 사항으로, 그룹화를 하지 않을 경우 생략할 수 있습니다.)
- **`ORDER BY`**: 각 그룹 내에서 데이터를 정렬하는 기준

> 주의 사항 : 윈도우 함수는 SELECT 절에서 독립적으로 사용되거나 서브쿼리로 분리되어야 합니다.
> 
<br>

### 주요 윈도우 함수

1. **`ROW_NUMBER()`**:
   - 각 행에 대해 고유한 순번을 부여합니다. 같은 순위가 없는 단독 순번입니다.
   - 예: 각 부서 내에서 직원의 순번을 부여.

2. **`RANK()`**:
   - 순위를 부여하되, 동점이 있을 경우 동일한 순위를 부여하고 다음 순위는 건너뜁니다.
   - 예: 매출액 기준으로 순위를 매기는데, 동일 매출액이 있으면 같은 순위를 부여.

3. **`DENSE_RANK()`**:
   - `RANK()`와 유사하지만, 다음 순위를 건너뛰지 않고 연속적인 순위를 부여합니다.
   - 예: 성적 순위에서 동일 점수는 같은 순위를 부여하고, 다음 순위는 건너뛰지 않음.

4. **`SUM()`**:
   - 각 행에 대해 누적 합계를 계산합니다.
   - 예: 판매 데이터를 월별로 누적 합계.

5. **`AVG()`**:
   - 각 행에 대해 이동 평균을 계산합니다.
   - 예: 최근 3개월 동안의 평균 판매량 계산.

6. **`LAG()`**:
   - 현재 행보다 이전 행의 값을 참조합니다.
   - 예: 전월 대비 이번 달의 판매량 차이 계산.

7. **`LEAD()`**:
   - 현재 행보다 다음 행의 값을 참조합니다.
   - 예: 다음 월의 예상 판매량과 현재 판매량 비교.

<br>

### 많이 활용되는 스킬 및 예제

### 1. 각 그룹의 첫 번째 행만 선택하기

```sql
# 각 부서에서 최고 연봉을 받는 직원만 선택하고 싶을 때
WITH RankedData AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rn
    FROM 
        Employees
)
SELECT * 
FROM RankedData 
WHERE rn = 1;
```

<br>

### 2. 누적 합계 계산

```sql
# 시간 순서대로 누적 판매 금액을 계산하고 싶을 때
SELECT 
    order_id,
    order_date,
    amount,
    SUM(amount) OVER (ORDER BY order_date) AS running_total
FROM 
    Orders;
```

<br>

### 3. 이전 행과의 차이 계산 (`LAG()` 활용)

```sql
# 매일의 판매량 변화를 계산하고 싶을 때
SELECT 
    order_id,
    order_date,
    amount,
    amount - LAG(amount, 1, 0) OVER (ORDER BY order_date) AS change_from_last
FROM 
    Orders;
```
<br>

### 4. 각 그룹 내 순위 계산 (`RANK()` 활용)

```sql
# 부서별로 직원의 연봉 순위를 계산하고 싶을 때
SELECT 
    employee_name,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
FROM 
    Employees;
```

<br>

### 5. 윈도우 함수와 조건부 집계 (Conditional Aggregation with Window Functions)

- 윈도우 함수는 조건부 집계와 결합할 수 있습니다. 이를 통해 특정 조건을 만족하는 행만을 집계하는 분석을 수행할 수 있습니다.
- **예시: 특정 조건에 따른 누적 합계**

```sql
SELECT 
    player_id,
    event_date,
    SUM(CASE WHEN event_type = 'win' THEN 1 ELSE 0 END) OVER (PARTITION BY player_id ORDER BY event_date) AS cumulative_wins
FROM 
    PlayerEvents;
```

<br>

### 6. 첫 번째 또는 마지막 값 가져오기 (FIRST_VALUE, LAST_VALUE)

- 특정 그룹 내에서 첫 번째 또는 마지막 값을 가져올 때 사용합니다.
- **예시: 부서 내 최초 입사자의 이름 가져오기**

```sql
# FIRST_VALUE(): 각 부서 내에서 가장 먼저 입사한 직원의 이름을 가져옵니다.
SELECT 
    department,
    employee_name,
    hire_date,
    FIRST_VALUE(employee_name) OVER (PARTITION BY department ORDER BY hire_date) AS first_hired_employee
FROM 
    Employees;
```

<br>

### 7. 복잡한 그룹 내 비율 계산 (Ratio Calculation within a Group)

- 특정 그룹 내에서의 비율이나 퍼센트를 계산할 때 윈도우 함수를 사용할 수 있습니다.
- 예시: 부서 내 각 직원의 급여가 부서 전체 급여에서 차지하는 비율

```sql
SELECT 
    department,
    employee_name,
    salary,
    ROUND(salary / SUM(salary) OVER (PARTITION BY department) * 100, 2) AS salary_percentage
FROM 
    Employees;
```


