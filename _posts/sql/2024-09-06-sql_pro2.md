---
layout: single
title: '[MySQL] SQL 문법 및 예제 정리 - LAG, LEAD, WITH, JOIN'
excerpt: "실무 적용 및 SQL 코테를 위한 자료입니다."
categories: SQL
tag : [mysql, lag, 실무, 정리, 총정리, 문법, 기초, 란, 설명, 코딩테스트, 코테]
toc: true
toc_sticky: true
sidebar_main: true

date: 2024-09-06
last_modified_at: 2024-09-06
---

<br>

## LAG(), LEAD() 함수

- MySQL 8.0부터 지원되는 `LAG()`와 `LEAD()` 함수는 데이터 분석에서 매우 유용한 윈도우 함수입니다. 이 두 함수는 현재 행을 기준으로 이전 또는 다음 행의 값을 참조할 수 있게 해줍니다.

### 1. `LAG()` 함수: 이전 행 값 가져오기

- `LAG()` 함수는 현재 행에서 **이전 행**의 값을 가져옵니다. 주로 변화 추적이나, 연속된 데이터의 차이를 계산할 때 사용됩니다.

```sql
# 예시
SELECT
    id,
    value,
    LAG(value, 1, 0) OVER (ORDER BY id) AS previous_value
FROM
    your_table;
```

- 이 쿼리는 각 행에 대해 이전 행의 `value` 값을 `previous_value`로 반환합니다. 첫 번째 행은 이전 행이 없으므로 기본값 `0`이 반환됩니다.

> LAG() 함수에서 PARTITION BY와 ORDER BY를 함께 사용하면, 데이터셋을 특정 그룹으로 나누고 각 그룹 내에서 순서에 따라 이전 행의 값을 참조할 수 있습니다.
> 이 기능은 주로 그룹별로 데이터의 변화를 추적하거나 비교할 때 유용합니다.

### 2. `LEAD()` 함수: 다음 행 값 가져오기

- `LEAD()` 함수는 현재 행에서 **다음 행**의 값을 참조합니다. 이는 미래 데이터를 미리 보여주거나, 현재 행과 다음 행 간의 차이를 계산할 때 유용합니다.

```sql
# 예시
SELECT
    id,
    value,
    LEAD(value, 1, 0) OVER (ORDER BY id) AS next_value
FROM
    your_table;
```
- 이 쿼리는 각 행에 대해 다음 행의 `value` 값을 `next_value`로 반환합니다. 마지막 행은 다음 행이 없으므로 기본값 `0`이 반환됩니다.

<br>

### 3. 활용 사례: 현재 행에서 다음 행의 차이 계산

- 두 함수를 활용해 현재 행과 다음 행의 값을 비교할 수 있습니다.

```sql
# 예시
SELECT
    id,
    value,
    value - LEAD(value) OVER (ORDER BY id) AS difference_with_next
FROM
    your_table;
```
- 이 쿼리는 각 행의 `value` 값과 다음 행의 `value` 값의 차이를 계산하여 `difference_with_next` 열에 표시합니다.

<br>

## 날짜(Date) 및 시간(Timestamp)

- MySQL에는 날짜와 시간을 처리하기 위한 다양한 함수들이 있습니다. 
- 이 함수들은 날짜와 시간의 연산, 형식 변환, 추출 및 포맷팅 등을 손쉽게 수행할 수 있게 해줍니다. 
- 아래는 MySQL에서 자주 사용되는 날짜 관련 함수들입니다.

<br>

### 1. 날짜 및 시간의 추가와 차이 계산

- **`DATE_ADD()`**: 특정 날짜에 지정된 기간을 더합니다.
  ```sql
  SELECT DATE_ADD('2024-09-06', INTERVAL 10 DAY);  -- 2024-09-16
  ```
- **`DATE_SUB()`**: 특정 날짜에서 지정된 기간을 뺍니다.
  ```sql
  SELECT DATE_SUB('2024-09-06', INTERVAL 10 DAY);  -- 2024-08-27
  ```
- **`DATEDIFF()`**: 두 날짜 간의 차이를 일 단위로 반환합니다.
  ```sql
  SELECT DATEDIFF('2024-09-16', '2024-09-06');  -- 10
  ```
- **`TIMESTAMPDIFF()`**: 두 날짜 또는 시간 간의 차이를 지정된 단위(초, 분, 시간 등)로 반환합니다.
  ```sql
  SELECT TIMESTAMPDIFF(HOUR, '2024-09-06 08:00:00', '2024-09-06 14:00:00');  -- 6
  ```

<br>

### 2. 날짜 및 시간 형식 변환

- **`STR_TO_DATE()`**: 문자열을 날짜로 변환합니다.
  ```sql
  SELECT STR_TO_DATE('06-09-2024', '%d-%m-%Y');  -- 2024-09-06
  ```
- **`DATE_FORMAT()`**: 날짜를 지정된 형식의 문자열로 변환합니다.
  ```sql
  SELECT DATE_FORMAT('2024-09-06', '%M %d, %Y');  -- September 06, 2024
  ```
- **`TIME_FORMAT()`**: 시간을 지정된 형식의 문자열로 변환합니다.
  ```sql
  SELECT TIME_FORMAT('14:30:00', '%h:%i %p');  -- 02:30 PM
  ```
  
<br>

### 3. 날짜 및 시간 비교

- **`DATE()`**: `DATETIME`이나 `TIMESTAMP` 타입에서 날짜 부분만 반환합니다.
  ```sql
  SELECT DATE('2024-09-06 14:30:00');  -- 2024-09-06
  ```
- **`TIME()`**: `DATETIME`이나 `TIMESTAMP` 타입에서 시간 부분만 반환합니다.
  ```sql
  SELECT TIME('2024-09-06 14:30:00');  -- 14:30:00
  ```

<br>

## WITH 

- `WITH` 구문은 MySQL에서 **공통 테이블 표현식**(CTE, Common Table Expression)을 정의할 때 사용됩니다. 
- CTE는 복잡한 쿼리를 더 읽기 쉽고 관리하기 쉽게 만들어줍니다. 

### 1. 기본 개념

- **CTE 정의**: `WITH` 뒤에 CTE 이름과 그 정의를 작성합니다. 이는 일종의 임시 테이블로, 이후 메인 쿼리에서 참조할 수 있습니다.
- **구조**: 
  ```sql
  WITH cte_name AS (
      SELECT ... -- CTE 정의 쿼리
  )
  SELECT ...
  FROM cte_name;
  ```

<br>

### 2. 사용 사례

1. **복잡한 쿼리의 간소화**:
   CTE를 사용하면 서브쿼리의 중첩을 피하고, 복잡한 쿼리를 단계별로 분리하여 이해하기 쉽게 만들 수 있습니다.
  
2. **재사용 가능한 쿼리**:
   동일한 중간 결과를 여러 번 사용해야 할 때, CTE를 정의하고 이를 참조하면 중복된 코드를 줄일 수 있습니다.

<br>

```sql
# 예시
WITH AvgSalary AS (
    SELECT department_id, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
)
SELECT employee_name, salary
FROM employees e
JOIN AvgSalary a ON e.department_id = a.department_id
WHERE e.salary > a.avg_salary;
-- CTE `AvgSalary`: 각 부서의 평균 급여를 계산
-- 메인 쿼리: 이 CTE를 참조해 평균 급여보다 높은 직원들을 선택
```

<br>

## JOIN

### CROSS JOIN

- CROSS JOIN은 모든 데이터가 서로 곱해서 출력됩니다.
- 또는 각각의 테이블을 콤마( , )를 이용해 이으면 모든 데이터가 서로 곱해서 출력됩니다.

```sql
-- cross join 
SELECT *
    FROM EMP
    CROSS JOIN DEPT;

-- ,로 연결 
SELECT * 
    FROM EMP, DEPT;
```

<br>

### 1. **집계 함수와 JOIN의 조합**

- **서브쿼리**에서 부서별 최대 급여를 구한 후, 이를 JOIN하여 해당 급여를 받는 직원을 찾습니다.
- 
```sql
# 예제: 부서별로 가장 높은 급여를 받는 직원 찾기
SELECT e.employee_name, e.salary, e.department_id
FROM employees e
JOIN (
    SELECT department_id, MAX(salary) AS max_salary
    FROM employees
    GROUP BY department_id
) AS dept_max
ON e.department_id = dept_max.department_id AND e.salary = dept_max.max_salary;
```

<br>

### 2. **SELF JOIN 활용**

- 자기 자신과의 JOIN을 통해 같은 부서에 속하지만, 다른 직원들을 조회할 수 있습니다.

```sql
# 예제: 직원 테이블에서 같은 부서에 속한 직원을 찾기
SELECT e1.employee_name AS employee, e2.employee_name AS colleague
FROM employees e1
JOIN employees e2
ON e1.department_id = e2.department_id
WHERE e1.employee_id <> e2.employee_id;
```

<br>

### 3. **EXISTS 서브쿼리와 JOIN의 결합**

- `EXISTS`는 서브쿼리가 결과를 반환하면 `TRUE`를 반환합니다. 따라서, 직원이 있는 부서만 결과로 반환됩니다.

```sql
# 예제: 부서에 직원이 존재하는 부서만 조회하기
SELECT d.department_name
FROM departments d
WHERE EXISTS (
    SELECT 1
    FROM employees e
    WHERE e.department_id = d.department_id
);
```

<br>

## WHERE vs ON vs HAVING

**이해 포인트**<br>**`WHERE`**: 행 단위로 데이터를 필터링합니다. 조인이나 그룹화 전에 사용됩니다.<br>
**`ON`**: 테이블을 결합할 때 어떤 조건으로 결합할지 지정합니다.<br>
**`HAVING`**: 그룹화된 결과에 대해 추가로 조건을 적용할 때 사용됩니다.
{: .notice--info}

### 1. `WHERE` 절

- **목적**: 개별 행을 필터링합니다.
- **적용 시점**: 테이블에서 데이터를 **조인하기 전**에 각 행에 대해 조건을 적용합니다.
- **사용 위치**: 일반적으로 `SELECT`, `UPDATE`, `DELETE` 문에서 사용됩니다.
- **예시**:
  ```sql
  # 주문 날짜가 2024년 1월 1일 이후인 행만 선택합니다.
  SELECT * 
  FROM Orders 
  WHERE order_date > '2024-01-01';
  ```
<br>

### 2. `ON` 절

- **목적**: 테이블 간의 조인 조건을 지정합니다.
- **적용 시점**: 두 테이블을 **조인할 때** 조건을 적용합니다.
- **사용 위치**: `JOIN` 문과 함께 사용됩니다.
- **예시**:
  ```sql
  # `Orders`와 `Customers` 테이블을 고객 ID를 기준으로 결합합니다.
  SELECT * 
  FROM Orders O
  JOIN Customers C 
  ON O.customer_id = C.customer_id;
  ```
  
ON 절에 조건을 포함시키면, 이 조건은 테이블이 결합될 때 즉시 적용됩니다. <br>
즉, 두 테이블이 조인될 때, 조건에 맞는 행만 결합되고, 그렇지 않은 경우에는 NULL이 반환됩니다. <br>
하지만 왼쪽 테이블의 모든 행은 유지됩니다.
{: .notice--danger}


<br>

### 3. `HAVING` 절

- **목적**: 그룹화된 데이터를 필터링합니다.
- **적용 시점**: **그룹화 및 집계된 후** 조건을 적용합니다.
- **사용 위치**: `GROUP BY` 문 뒤에 사용됩니다.
- **예시**:
  ```sql
  # 고객별로 주문 금액을 합산한 후, 그 합계가 1000을 초과하는 그룹만 선택합니다.
  SELECT customer_id, SUM(order_amount) AS total_spent
  FROM Orders
  GROUP BY customer_id
  HAVING total_spent > 1000;
  ```
<br>

- **세 절의 비교 요약**

  | 절      | 주요 목적                       | 적용 시점           | 사용 위치      |
  |---------|--------------------------------|---------------------|----------------|
  | `WHERE` | 개별 행 필터링                   | 조인 전 또는 그룹화 전 | `SELECT`, `UPDATE`, `DELETE` |
  | `ON`    | 테이블 간의 조인 조건 지정       | 조인 시점            | `JOIN`        |
  | `HAVING`| 그룹화된 데이터 필터링           | 그룹화 및 집계 후    | `GROUP BY` 뒤 |







