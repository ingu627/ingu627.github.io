---
layout: single
title: "운영체제 1장: 운영체제 개요 (정리)"
excerpt: "본 글은 (KOCW) 운영체제, 이화여자대학교 반효경 교수님의 강의를 듣고 개인 공부에 목적으로 내용을 요약 및 정리했습니다. <br> 또한 주니온 박사님의 운영체제 공룡책 강의를 듣고 내용을 보충했습니다."
categories: OS
tags: [OS, 운영체제, 동시 작업, 처리 방식, 컴퓨터, 인터럽트, 커널, 프로그램, 개요, 프로세스, 란, 정의, 개념, pdf, 정리]
toc: true
toc_sticky: true
sidebar_main: false

last_modified_at: 2022-08-07
---

본 글은 (KOCW) 운영체제(반효경 교수) 및 주니온 박사 공룡책 강의를 토대로 핵심만 정리한 개인 학습 노트이다. 자세한 강의 내용은 각 강좌 원문을 참고한다.
{: .notice--info}

![image](https://user-images.githubusercontent.com/78655692/147717027-fcfaf167-79a5-4ce2-8d43-0801ef2df945.png)
![image](https://user-images.githubusercontent.com/78655692/158063378-b6937f70-2b74-4afb-8103-1fe278a3c340.png)
---

운영체제가 무엇인지 먼저 감을 잡자
-------------------------------------

우리가 실행하는 거의 모든 프로그램은 직접 하드웨어를 다루지 않고 운영체제를 거친다. 운영체제(OS)는 CPU, 메모리, 디스크, 입출력 장치 위에 얇지만 핵심적인 관리 층을 두어 사용자가 복잡한 하드웨어 차이를 의식하지 않고 동일한 방식으로 프로그램을 실행하게 만든다. 협의로 커널은 항상 메모리에 상주하는 핵심 부분을 뜻하고, 광의로는 커널과 그 위에서 시스템 환경을 구성하는 각종 유틸리티(쉘, 기본 도구)까지 포함한다.

운영체제의 목표는 두 문장으로 요약한다. 첫째, 한정된 하드웨어 자원을 여러 프로그램이 공정하고 효율적으로 나눠 쓰게 관리한다. 둘째, 사용자가 하드웨어 세부(레지스터, 디바이스 레지스터, 인터럽트 라인)를 몰라도 프로그램을 쉽게 실행·저장·통신하게 하는 편의 계층을 제공한다.

어떤 종류의 환경을 지원하는가
-----------------------------------

초기의 단일 작업 시스템은 한 번에 하나의 작업만 처리했지만, 오늘날 대부분은 다중 작업(multi-tasking)을 지원하여 사용자가 편집기, 브라우저, 음악 재생기를 동시에 띄운다. 사용자 관점에서 여러 개가 동시에 움직이는 것처럼 보이지만 실제로는 CPU가 짧은 시간 단위로 번갈아 다른 프로세스를 실행한다. 다중 사용자 시스템에서는 서로 다른 계정이 동일 머신 자원을 공유한다. 처리 방식은 크게 세 가지로 요약한다. 일괄처리(batch)는 한 덩어리 작업을 모아 순차 처리하여 처리량을 높이지만 대기 시간이 길다. 시분할(time sharing)은 빠른 문맥 교환을 통해 키보드/화면 상호작용 응답성을 확보한다. 실시간(real-time) 시스템은 지정된 시간 안에 작업이 반드시 끝나도록 하는 시간 결정성(determinism)을 가장 중요하게 둔다. 경성(Hard) 실시간은 마감 위반을 허용하지 않고, 연성(Soft)은 일부 위반을 성능 저하로만 본다.

프로그램이 ‘프로세스’가 되는 순간
-------------------------------------

디스크에 저장된 실행 파일은 그 자체로는 정적인 명령어와 데이터 묶음이다. 사용자가 실행하면 운영체제가 메모리에 적절한 주소 공간을 만들고 코드/데이터/힙/스택 구조를 채워 넣은 뒤 CPU에게 실행을 넘긴다. 이 살아 움직이는 실행 단위를 프로세스라고 부른다. 여러 번 실행하면 동일한 프로그램이라도 서로 다른 PID(식별자)를 가진 여러 프로세스가 된다.

인터럽트와 시스템 콜: 경계 넘어가기
-----------------------------------------

하드웨어는 예상치 못한 사건(디스크 읽기 완료, 네트워크 패킷 도착)을 인터럽트 신호로 알리고 CPU는 즉시 현재 하던 일을 잠시 저장한 뒤 커널이 준비한 처리 루틴에 진입한다. 반대로 사용자 프로그램이 운영체제의 도움(파일 열기, 소켓 생성)이 필요할 때는 시스템 콜을 사용해 의도적으로 커널 모드로 들어간다. 두 경우 모두 사용자 코드와 커널 코드 사이 경계가 안전하게 유지되도록 CPU는 모드 비트와 인터럽트 벡터 테이블을 활용한다.

왜 ‘가상화’가 중요한가
---------------------------

운영체제는 실제 물리 자원을 그대로 노출하지 않고 추상화(virtualization)하여 각 프로세스가 마치 자신만의 독립 CPU와 독립 메모리를 가진 것처럼 보이게 만든다. CPU 스케줄러는 시간 조각을 쪼개 CPU를 ‘가상 CPU’ 여러 개로 나눈 것 같은 환상을 주고, 가상 메모리 관리자는 큰 연속된 주소 공간을 제공하면서 실제로는 필요한 페이지 부분만 물리 메모리에 올린다. 이렇게 하면 안전성(다른 프로세스 메모리에 침범할 수 없음)과 자원 활용 효율을 동시에 잡는다.

주요 구성 요소를 이야기로 훑기
-----------------------------------

프로세스 관리자는 새로운 프로세스를 만들고(fork/exec), 끝내고(exit), 동시에 실행할 순서를 정한다. 메모리 관리자는 누가 어떤 주소 범위를 쓰는지 추적하고 부족하면 디스크(스왑 영역)를 임시로 빌린다. 파일 시스템은 디스크를 계층적 디렉터리와 파일이라는 인간친화적 이름 공간으로 바꾼다. I/O 서브시스템은 장치마다 다른 속도·프로토콜을 드라이버를 통해 통일된 호출로 감싼다. 보호/보안 계층은 권한, 계정, 자원 사용량을 기록해 오·남용을 막는다.

서로 다른 처리 방식이 주는 사용자 경험
-------------------------------------------

일괄처리 환경에서는 ‘작업을 제출하고 결과를 한참 뒤에 받는다’는 흐름이 자연스럽다. 반면 시분할 시스템에서는 명령을 치면 즉시 화면에 반응이 돌아오며, 내부적으로는 문맥 교환 비용이 늘어난다. 실시간 시스템은 응답 속도보다 “시간 안에 끝마침”을 보장하는 스케줄링(예: Rate Monotonic, EDF 등)이 더 중요하다. 이 차이가 곧 운영체제 구조 설계의 우선순위를 결정한다.

다양한 ‘멀티’ 용어 정리 (설명형)
-----------------------------------

멀티프로그램밍은 메모리에 여러 프로그램을 동시에 올려 CPU 놀림을 줄이려는 초기 기법이다. 멀티태스킹은 사용자가 체감하는 상호작용 위주의 동시 실행 경험을 강조한다. 멀티프로세싱은 실제 물리 CPU(코어)가 여러 개라 병렬 실행이 가능함을 의미한다. 멀티코어는 하나의 칩 안에 연산 코어가 여러 개인 구조를 가리키며 캐시 공유나 NUMA 같은 추가 고려가 따른다.

예제를 통한 큰 그림 묘사
--------------------------------

텍스트 편집기를 실행한다고 하자. 실행 파일을 더블클릭하면 OS가 프로세스를 구성하고, 키 입력은 인터럽트로 커널에 전달되며 다시 편집기 프로세스의 입력 버퍼로 전달된다. 저장 명령을 내리면 시스템 콜을 통해 파일 시스템 계층이 디스크 드라이버를 호출하고, 디스크 완료 인터럽트가 도착하면 커널이 편집기에게 ‘쓰기 완료’ 사실을 알려준다. 이 짧은 흐름 속에 스케줄링, 가상 메모리, 인터럽트, 파일 시스템이 모두 개입한다.

한 문장 정리와 기억 포인트
---------------------------------

운영체제는 “자원을 가상화하고, 보호하고, 효율적으로 공유시키면서, 통일된 인터페이스로 프로그램 실행을 뒷받침하는 관리자”이다. 내부를 처음부터 모두 외울 필요는 없다. ‘왜 이런 추상화를 만들었는가’라는 질문을 붙여 읽으면 개념이 자연스럽게 연결된다.

---

추가로 더 풀어서 듣고 싶은 부분(예: 스케줄러 정책, 가상 메모리 세부) 있으면 알려주기 바란다. 이후 장들도 동일한 서술 톤으로 조정 가능하다.
