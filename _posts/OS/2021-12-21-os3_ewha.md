---
layout: single
title: "운영체제 3장: 프로세스와 관리 (정리)"
excerpt: "본 글은 (KOCW) 운영체제, 이화여자대학교 반효경 교수님의 강의를 듣고 개인 공부에 목적으로 내용을 요약 및 정리했습니다. <br> 또한 주니온 박사님의 운영체제 공룡책 강의를 듣고 내용을 보충했습니다."
categories: OS
tags: [OS, 운영체제, 프로세스, 프로세스 관리, process, thread, management, context switch, 문맥 교환, scheduling, fork, exec, wait, exit, message passing, PCB, queue, 스레드, pdf, 정리]
toc: true
toc_sticky: true
sidebar_main: false

last_modified_at: 2022-06-19
---

본 글은 (KOCW) 운영체제 + 공룡책 강의를 참고하여 프로세스 / 스레드 / 스케줄링 기초를 핵심 위주로 정리한 개인 노트이다.
{: .notice--info}

![image](https://user-images.githubusercontent.com/78655692/147717027-fcfaf167-79a5-4ce2-8d43-0801ef2df945.png)
![image](https://user-images.githubusercontent.com/78655692/158063378-b6937f70-2b74-4afb-8103-1fe278a3c340.png)


<br>

## 1. 프로세스 개념

프로세스 = 실행 중인 프로그램 인스턴스. 고유 PID를 가지며 (1) CPU 문맥(PC, 레지스터) (2) 주소 공간(code/data/heap/stack) (3) 커널 자료구조(PCB, 커널 스택)로 구성된다.

<br>

### 상태 전이 핵심 5 + 2

New → Ready → Running → (I/O) Blocked → Ready → ... → Terminated. 추가로 메모리에서 쫓겨난 Suspended(Ready/Blocked) 상태가 존재한다.

<br>

### PCB 구성 요약

| 범주 | 내용 |
|------|------|
| 식별 | PID, PPID, 사용자/그룹 ID |
| 실행 상태 | Process state, 스케줄링 우선순위/큐 링크 |
| CPU 문맥 | PC, 레지스터, PSW(플래그) |
| 메모리 | 코드/데이터/스택, 페이지 테이블 or 세그먼트 정보 |
| 파일 | 열린 파일 디스크립터 테이블 |
| 기타 | 사용량 회계, 시그널/핸들러, 자원 제한 |

<br>

### 문맥 교환

실행 중 프로세스의 레지스터/PC/상태를 PCB에 저장 후 다른 PCB 내용 복원. 오버헤드이므로 스케줄링 정책은 불필요한 교환을 줄이도록 설계한다.

<br>

### 스케줄링 큐

Job(시스템 전체) → Ready(메모리 상 대기) ↔ Running ↔ Device(I/O 대기). 다단계 큐/우선순위 큐는 정책 구현 형태이다.

<img src="https://user-images.githubusercontent.com/78655692/160361966-c0752634-d46a-4aff-bdb9-499a7fd9cbe1.png" width=600>

<br>

### 스케줄러 종류

| 종류 | 역할 | 비고 |
|------|------|------|
| Long-term | 시스템 입장 프로세스 제어 | 시분할 환경에서는 약함/없음 |
| Short-term | 다음 실행 프로세스 선택 | 밀리초 단위 속도 요구 |
| Medium-term | 메모리에서 Swap in/out | 멀티프로그래밍 정도 조절 |

<br>

Suspended는 외부 resume 필요. Blocked는 이벤트 완료로 Ready 복귀.

<img src="https://user-images.githubusercontent.com/78655692/147465810-25cea352-d9b5-42c9-b2f6-907b77885e5f.png" width=600>

<br>

## 2. 스레드

스레드는 프로세스 내부의 실행 단위이며 PC/레지스터 세트/개별 스택을 가지고 코드/데이터/히프/열린 파일 등은 공유한다.

<img src="https://user-images.githubusercontent.com/78655692/147519495-fa41c193-94c2-4300-886d-8324a06c8564.png" width=600>

<br>

<img src="https://user-images.githubusercontent.com/78655692/147519517-d5ec2c49-2095-4fed-ba11-553a04c7828b.png" width=600>

<br>

멀티스레딩은 I/O 대기 중 다른 스레드로 응답성 향상·리소스 공유·MP 활용·Context switch 비용 감소 효과를 노린다.

<br>

### 장점 요약

응답성 / 자원 공유 / 경제성 / 다중코어 활용.

<br>

### 구현 모델

| 모델 | 특징 | 장점 | 단점 |
|------|------|------|------|
| User-level | 커널 모름, 라이브러리 스케줄링 | 빠른 생성/전환 | 블로킹 시스템콜 전체 정지, 다코어 활용 제한 |
| Kernel-level | 커널이 각각 인식 | 병렬성, 블로킹 영향 국소화 | 전환 비용 큼 |
| 혼합(M:N) | 사용자 다수 ↔ 커널 스레드 일부 매핑 | 유연성 | 구현 복잡 |

<br>

### Process vs Thread 핵심 대비

프로세스는 자원 컨테이너, 스레드는 실행 단위. 스레드 간 공유로 문맥교환이 부분적(레지스터+스택). 프로세스 전환보다 비용 낮다.

<br>

### 스레드 매핑 요약

| 모델 | 사용자:커널 | 비고 |
|------|-------------|------|
| Many:One | N:1 | 병렬성 X, 구현 단순 |
| One:One | 1:1 | 병렬성 O, 전환 오버헤드 ↑ |
| Many:Many | N:M | 유연, 구현 복잡 |


<br>

## 3. 프로세스 생성/종료

UNIX 계열: fork()로 부모 주소 공간 Copy-on-Write 공유 → 필요 시 페이지 복사. exec() 호출 시 새 실행 이미지 적재. wait()는 자식 종료 기다림, exit()는 자원 반납·상태 코드 전달. 부모 종료 시 자식은 init(or systemd)로 재부모(adopt)되거나 함께 종료.

<br>

주요 시스템 콜 요약: fork(), exec(), wait(), exit(), kill().

<img src="https://user-images.githubusercontent.com/78655692/161482364-b6570acd-3fff-4948-9a2c-8ac848e2509c.png" width=700>

<br>

종료 유형: 정상(return/exit), 비정상(signal, kill -9 등), 부모 종료에 따른 연쇄.

<br>

## 4. 프로세스 간 통신(IPC)

두 범주: (1) 공유 메모리 (빠름, 동기화 필요) (2) 메시지 전달 (커널 중재, 안전성). 스레드는 동일 프로세스 내 협력이라 IPC보단 intra-process 공유.

<img src="https://user-images.githubusercontent.com/78655692/160363246-817192c5-a7ad-48f3-b3ab-3ca02123dffe.png" width=600>

<br>

공유 메모리는 생산자-소비자(Producer-Consumer) 패턴의 대표적 적용. 별도 동기화(뮤텍스/세마포) 필요.

<br>

메시지 전달은 직접(프로세스 주소지정) / 간접(mailbox) 모델이 있다. 송수신은 blocking/non-blocking 조합으로 동작하며, 큐 용량에 따라 동기화 패턴이 달라진다.

<br>

---

### 핵심 한 줄 요약
프로세스는 자원 컨테이너, 스레드는 그 안의 실행 실체, IPC는 공유/메시지 두 축이다.

필요 이상의 반복 이미지와 장황한 문장을 삭제하고 표/구조 중심으로 재구성했다. 더 다듬을 부분이 있으면 알려주기 바란다.