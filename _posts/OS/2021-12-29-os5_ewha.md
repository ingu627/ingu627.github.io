---
layout: single
title: "OS - CPU Scheduling (5)"
excerpt: "본 글은 (KOCW) 운영체제, 이화여자대학교 반효경 교수님의 강의를 듣고 내용을 요약 및 정리했습니다. <br> 개인 공부에 목적이 있으며, 자세한 사항은 <http://www.kocw.or.kr/home/cview.do?mty=p&kemId=1046323>에 참고하시면 됩니다."
categories: OS
tag : [OS, 운영체제, CPU, 스케줄링]
toc: true
toc_sticky: true
sidebar_main: true

last_modified_at: 2021-12-29
---

본 글은 (KOCW) 운영체제, 이화여자대학교 반효경 교수님의 강의를 듣고 내용을 요약 및 정리했습니다. <br> 개인 공부에 목적이 있으며, 자세한 사항은 <http://www.kocw.or.kr/home/cview.do?mty=p&kemId=1046323>에 참고하시면 됩니다.
{: .notice--info}

<br>
<br>

## CPU and I/O Bursts in Program Execution

![image](https://user-images.githubusercontent.com/78655692/147648474-047bc1f6-26c3-46a1-9943-822d252037ed.png)

- CPU와 I/O가 번갈아가면서 실행

<br>

## CPU-burst Time의 분포

![image](https://user-images.githubusercontent.com/78655692/147648878-168d6f76-6cea-45b4-b0a1-f7c7ac2e4031.png)

- 여러 종류의 job(=process)이 섞여 있기 때문에 CPU 스케줄링이 필요하다.
  - Interactive job에게 적절한 response 제공 요망
  - CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용

<br>

## 프로세스의 특성 분류

- 프로세스는 그 특성에 따라 다음 두 가지로 나눔
  - `I/O-bound process`
    - CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job
    - (many short CPU bursts)
  - `CPU-bound process`
    - 계산 위주의 job
    - (few very long CPU bursts)

<br>

## CPU Scheduler & Dispatcher

- **CPU Scheduler** : Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다.
- **Dispatcher** : CPU의 제어권을 CPU scheduler에 의해 선택된 프로세스에게 넘긴다. 이 과정을 `context switch` (문맥 교환)라고 한다.
- CPU 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태 변화가 있는 경우이다.
    1. Running -> Blocked (ex. I/O 요청하는 시스템 콜)
    2. Running -> Ready (ex. 할당시간만료로 timer interrupt)
    3. Blocked -> Ready (ex. I/O 완료후 인터럽트)
    4. Terminate
  - 1,4에서의 스케줄링은 `nonpreemptive` (비선점형) (=강제로 빼앗지 않고 자진 반납)
  - All other scheduling is `preemptive` (선점형) (=강제로 빼앗음)

<br>

## Scheduling Criteria (성능 척도)

- `CPU utilization` (이용률) : 전체 시간 중 CPU가 놀지 않고 일한 비율
- `Throughput` (처리량) : 주어진 시간동안 과연 몇 개의 작업을 처리했느냐
- `Turnaround time` (소요시간, 반환시간) : [고객 입장] CPU를 얻어서 쓰고 나갈 때까지의 시간
- `Waiting time` (대기 시간) : [고객 입장] CPU를 쓰기 위해 기다린 시간
- `Response time` (응답 시간) : [고객 입장] : 처음으로 CPU를 얻기까지의 시간

<br>

## Scheduling Algorithms

### FCFS (First-Come First-Served)

- 먼저 온 순서대로 처리
- 스케줄 순서를 `Gantt Chart`로 나타내면 다음과 같다.
- FCFS는 앞에 어떤 프로세스가 버티냐에 따라서 기다리는 시간에 많은 영향을 끼친다.
  - `Convoy effect` : 긴 프로세스 앞에 놓인 짧은 프로세스가 있을 때

![image](https://user-images.githubusercontent.com/78655692/147656793-fde64f80-0b7a-4b22-96ec-4df782b41201.png) [^1]

- Wiating time for $P_1$ = 0; $P_2$ = 24; $P_3$ = 27
- Average waiting time : (0 + 24 + 27)/3 = 17

### SJF (Shortest-Job-First)

- 각 프로세스의 다음번 CPU burst time을 가지고 스케줄링에 활용
- `CPU burst time`이 가장 짧은 프로세스를 제일 먼저 스케줄


<br>
<br>

## References

[^1]: <https://dev.to/nagasaisriya/operating-systems-scheduling-algorithms-made-easy-fcfs-51nm>




