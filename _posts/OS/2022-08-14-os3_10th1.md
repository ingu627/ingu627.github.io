---
layout: single
title: "[Operating System Concepts 10th] 3. Processes 리뷰 (1)"
excerpt: "본 글은 Operating System Concepts 10th (운영체제) 책을 보며 내용을 개인 공부에 목적으로 정리했습니다. 책 내용들을 최대한 이해하기 위해 거의 모든 내용을 담고 있습니다. 3. Processes (1)"
categories: OS
tag : [OS, 운영체제, 정리, pdf, 프로세스, process, 문맥, 컨텍스트, 프로그램 카운터, 힙, 스택, 동적, 상태, pcb, 스레드, 스케줄링, 시스템 콜, 준비, 대기, 실행, 종료]
toc: true
toc_sticky: true
sidebar_main: true

last_modified_at: 2022-08-14
---

<img align='right' width='150' height='200' src='https://user-images.githubusercontent.com/78655692/184343886-e144daea-afbd-43b6-90f9-1638c89a089c.png'>
본 글은 Operating System Concepts 10th (운영체제) 책을 보며 내용을 개인 공부에 목적으로 정리했습니다.<br> 이전에 운영체제 관련 강의들을 들으면서 정리한 시리즈 글들이 있는데, 지식을 습득하는 데 있어 가장 느리지만 가장 빠른 방법이 원본책을 자세히 보는 것이라 생각됩니다. <br> 책 내용들을 최대한 이해하기 위해 거의 모든 내용을 담고 있습니다. <br><br> 책 pdf 링크 : [Operating System Concepts 10th Edition by Abraham Silberschatz Peter B Galvin Greg Gagne pdf free download](https://www.booksfree.org/operating-system-concepts-10th-edition-by-abraham-silberschatz-peter-b-galvin-greg-gagne-pdf/)
{: .notice--info}

<br>
<br>

## 3. Process

- 오늘날의 컴퓨터 시스템들은 메모리에 다수의 프로그램이 적재(load)되어 병행(concurrent) 실행되는 것을 허용한다.
- 이러한 발전은 다양한 프로그램을 보다 견고하게 제어하고 보다 구획화(compartmentalization)할 것을 필요로 했고, 프로세스의 개념이 등장했다.
  - 프로세스는 실행 중인 프로그램을 말하며, 현대 컴퓨터 시스템에서 작업의 단위이다.

<br>

- **목표**
  1. 프로세스의 개별 구성요소를 식별하고 운영체제에서 해당 구성요소가 어떻게 표현되고 스케줄 되는지 기술한다.
  2. 운영체제에서 프로세스를 생성하고 종료하는 방법을 설명한다. 이러한 작업을 수행하는 적절한 시스템 콜을 사용하여 프로그램의 개발 등이 포함된다.
  3. 공유 메모리 및 메시지 전달을 사용하는 프로세스 간 통신을 설명하고 대조한다.
  4. 파이프와 POSIX 공유 메모리를 사용하여 프로세스 간 통신을 수행하는 프로그램을 설계한다.
  5. 소켓과 원격 프로시저 호출을 사용하여 클라이언트-서버 통신을 설명한다.
  6. Linux 운영체제와 상호 작용하는 커널 모듈을 설계한다.

<br>
<br>

## 3.1 Process Concept

- 초창기 컴퓨터는 CPU 활동들을 작업(job)을 실행하는 일괄처리(batch) 시스템이었고, 사용자 프로그램(user program) 또는 태스크(task)를 실행하는 시분할 시스템이 뒤를 이었다.
- 현대에 와서 이러한 모든 활동을 **프로세스**라고 부른다.

<br>

### 3.1.1 The Process

- 프로세스의 현재 활동의 상태(status)는 **프로그램 카운터(program counter)** 값과 프로세서 레지스터의 내용으로 나타낸다.
  - **프로그램 카운터(program counter)** : 마이크로프로세서 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. (=명령어 포인터) [^1]
- 프로세스의 메모리 배치는 다음 그림과 같이 여러 섹션으로 구분된다.

![image](https://user-images.githubusercontent.com/78655692/184521162-cf424ff4-7c04-46a2-9f69-b37e8563a708.png)

- **Text section** : 실행가능한 코드
- **Data section** : 전역 변수(global variable)
- **Heap section** : 프로그램 실행 중에 동적으로 할당되는 메모리
  - **동적(dynamic)** : 그때 그때 생성하는 것을 말한다.
- **Stack section** : 함수를 호출할 때 임시 데이터 저장장소(함수 파라미터, 리턴 주소, 지역 변수)

<br>

- 텍스트 및 데이터 섹션의 크기는 고정되기 때문에 프로그램 실행 시간 동안 크기가 변하지 않는다. 그러나 스택 및 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수 있다.
  - 함수가 호출될 때마다 함수 파라미터, 지역 변수 및 리턴 주소를 포함하는 **활성화 레코드(activation record)**가 스택에 푸시(push)된다.
  - 함수로부터 제어(control)가 리턴되면 스택에서 활성화 레코드가 팝(pop) 된다.
  - 메모리가 동적으로 할당됨에 따라 힙이 커지고 메모리가 시스템에 반환되면 축소된다.

<br>

- 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다.
- 프로세스가 실행되는 과정에서 많은 프로세스를 생성하는 것이 보통이다.
- 예를 들어 대부분의 상황에서 실행 가능한 Java 프로그램은 JVM 안에서 실행된다. JVM은 적재된 Java 코드를 해석하고 그 코드를 대신하여 원 기계어를 이용하여 행동을 취하는 프로세스로서 프로그램을 실행한다.
- 다음은 C 프로그램의 메모리 배치 그림이다.

![image](https://user-images.githubusercontent.com/78655692/184521604-2359c50d-2467-406c-afc0-63dd9f8a0724.png)

<br>

### 3.1.2 Process State

![image](https://user-images.githubusercontent.com/78655692/184521611-8993ca38-dd6a-4c33-9682-7760b293b7b5.png)

- 프로세스는 실행되면 그 상태(state)가 변한다.
- 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다.
- **새로운(new)** : 프로세스가 생성중이다.
- **실행(running)** : 명령어들이 실행되고 있다.
- **대기(waiting)** : 프로세스가 어떤 이벤트(입출력 완료 등)가 일어나기를 기다린다.
- **준비(ready)** : 프로세스가 프로세서에 할당되기를 기다린다.
- **종료(terminated)** : 프로세스의 실행이 종료되었다.

<br>

### 3.1.3 Process Control Block

- 각 프로세스는 운영체제에서 **프로세스 제어 블록(process control block, PCB)**에 의해 표현된다.

![image](https://user-images.githubusercontent.com/78655692/184521778-7d82eef8-5c9b-4b24-a02b-bc6e5e62a62b.png)

- PCB는 특정 프로세스와 연관된 여러 정보를 수록하며, 다음과 같은 것들을 포함한다.
  - **프로세스 상태(process state)** : new, ready, running, waiting, halted(정지) 상태 등이다.
  - **프로그램 카운터(program counter)** : 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
  - **CPU 레지스터들(registers)** : 레지스터에는 누산기(accumulator), 인덱스 레지스터, 스택 레지스터, 범용 레지스터들과 상태 코드 정보가 포함된다.
  - **CPU-스케줄링 정보** : 이 정보는 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 파라미터를 포함한다.
  - **메모리 관리 정보(memory-management information)** : 이 정보는 운영체제에 의해 사용되는 메모리 시스템에 따라 기준(base) 레지스터와 한계(limit) 레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블(page table) 또는 세그먼트 테이블(segment table) 등과 같은 정보를 포함한다.
  - **회계(accounting) 정보** : 이 정보는 CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함한다.
  - **입출력 상태 정보** : 이 정보는 이 프로세스에 할당된 입출력 장치들과 open 파일의 목록 등을 포함한다.
- 즉, PCB는 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소의 역할을 한다.

<br>

### 3.1.4 Threads

- 단일 제어 스레드는 프로세스가 한 번에 한 가지 일만 실행하도록 허용한다.
- 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 한다.
  - 프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용한다.
  - ex. 워드 프로세서는 하나의 스레드에 사용자 입력 관리를 맡기는 동안 다른 스레드가 철자 검사기를 수행하도록 만들 수 있다.

<br>

## 3.2 Process Scheduling

- 멀티 프로그래밍의 목적은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행되도록 하는 데 있다.
- 시분할(time sharing)의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것이다.
- 이 목적을 달성하기 위해 프로세스 스케줄러(process scheduler)는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다.

<br>

### 3.2.1 Scheduling Queue

![image](https://user-images.githubusercontent.com/78655692/184524747-3117fd5c-f093-4ff7-a293-747b0db80fe6.png)

- 프로세스가 시스템에 들어가면 준비(ready) 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다. 
- 이 큐는 연결 리스트로 저장된다.
- 준비 큐 헤더(header)에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함된다.
- I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐에 삽입된다.

<br>

![image](https://user-images.githubusercontent.com/78655692/184524824-0f145a61-fcf9-42e5-9329-a8a1ed8d0a38.png)

- 프로세스 스케줄링의 일반적인 표현은 Figure 3.5와 같은 큐잉 다이어그램(queueing diagram)이다.
- 준비 큐와 대기 큐의 집합의 2가지 유형의 큐가 제시되어 있다.
- 원은 큐에 서비스를 제공하는 자원을 나타내고 화살표는 시스템의 프로세스의 흐름을 나타낸다.
- 새 프로세스는 처음에 준비 큐에 놓인다. 프로세스는 실행을 위해 선택되거나 또는 디스패치 될 때까지 기다린다.
- 프로세스에 CPU 코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생할 수 있다.

<br>

### 3.2.2 CPU Scheduling

- 프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이동한다(migrate).
- CPU 스케줄러(cpu scheduler)의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것이다.
  - CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.
- 일부 운영체제는 **스와핑(swapping)**으로 알려진 중간 형태의 스케줄링을 가지고 있다.
  - 핵심 아이디어는 메모리에서 프로세스를 제거하여 멀티 프로그래밍의 정도를 감소시키는 것이 유리할 수 있다는 것이다.
  - 프로세스를 메모리에서 디스크로 스왑아웃(swapped out)하고 현재 상태를 저장하고, 이후 디스크에서 메모리로 스왑인(swapped in)하여 상태를 복원할 수 있기 때문에 이 기법을 **스와핑(swapping)**이라 한다.
  - 스와핑은 일반적으로 메모리가 초과 사용되어 가용공간을 확보해야 할 때만 필요하다.

<br>

### 3.2.3 Context Switch

- 인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어 커널 루틴을 실행할 수 있게 한다.
- 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 컨텍스트(context)를 복구할 수 있도록 현재 실행 중인 프로세스의 현재 컨텍스트를 저장할 필요가 있다.
  - **컨텍스트(context)** : 현재 CPU를 사용중인 프로세스의 CPU 제어권이 다른 프로세스로 이양되는 과정 [^2]
- 컨텍스트는 프로세스의 PCB에 표현된다.
- 컨텍스트는 CPU 레지스터의 값, 프로세스의 상태, 메모리 관리 정보 등을 포함한다.
  - 일반적으로 커널 모드이건 사용자 모드이건 CPU의 현재 상태를 저장하는(state save) 작업을 수행하고, 나중에 연산을 재개하기 위하여 상태 복구 작업(state restore)을 수행한다.

<br>

- CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요한데, 이 작업을 **컨텍스트 교환(context switch)**라 한다.

![image](https://user-images.githubusercontent.com/78655692/184526591-e91bdacb-3986-4e93-a039-d96f9bef34c8.png)

- 컨텍스트 교환이 일어나면, 커널은 과거 프로세스의 컨텍스트를 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 컨텍스트를 복구한다.
  - 컨텍스트 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 컨텍스트 교환 시간은 순수한 오버헤드이다.
  - **오버헤드(overhead)** : 컨텍스트 교환에 필요한 시간, 메모리 등을 말한다.

<br>
<br>

## 3.2 Operation on Processes

- 대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고, 제거되어야 한다. 
- 그러므로 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.

<br>

### 3.3.1 Process Creation

- 실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있다.
- 생성하는 프로세스를 부모(parent) 프로세스라고 부르고, 새로운 프로세스는 자식(child) 프로세스라고 부른다.
- 이 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며, 그 결과 프로세스의 트리(tree)를 형성한다.
- 운영체제는 고유한 프로세스 식별자(process identifier, pid)를 사용하여 프로세스를 구분한다.
- 이 식별자를 통하여 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 인덱스로 사용된다.

![image](https://user-images.githubusercontent.com/78655692/184527230-3d3e231a-5e7d-4a90-92d1-cf6201858c0a.png)

<br>

- 프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 가능한 방법이 존재한다.

  1. 부모는 자식과 병행하게 실행을 계속한다.
  2. 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.

- 새로운 프로세스들의 주소 공간 측면에서 볼 때 다음과 같은 두 가지 가능성이 있다.

  1. 자식 프로세스는 부모 프로세스의 복사본이다.
  2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.

<br>

![image](https://user-images.githubusercontent.com/78655692/184528462-f381e61c-4107-42d6-92de-b588160fceec.png)

- UNIX 시스템 콜을 봐본다. (figure 3.9)
- 동일한 프로그램의 복사본을 실행하는 두 개의 서로 다른 프로세스를 갖는다.
  - 유일한 차이점은 자식 프로세스에 보이는 pid의 값은 0이고, 반면에 부모 프로세스에게 보이는 pid 값은 0보다 큰 정수 값이라는 것이다.
- 자식 프로세스는 오픈 파일과 같은 리소스뿐 아니라 특권과 스케줄링 속성을 부모 프로세스로부터 상속받는다.
- 그런 후에 자식 프로세스는 exec() 시스템 콜을 사용하여 자신의 주소 공간을 UNIX 명령 /bin/ls로 덮어쓴다.
- 부모는 wait() 시스템 콜로 자식 프로세스가 끝나기를 기다린다.
- 자식 프로세스가 끝나면, 부모 프로세스는 wait() 호출로부터 재개하여, exit() 시스템 콜을 사용하여 끝낸다.

<br>

### 3.3.2 Process Termination

- 프로세스가 마지막 문장의 실행을 끝내고, exit 시스템 콜을 사용하여 운영체제에 자신의 삭제를 요청하면 종료한다.
- 이 시점에서, 프로세스는 자신을 기다리고 있는 부모 프로세스에 상태 값을 반환할 수 있다.
- 물리 메로리와 가상 메모리 오픈 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 할당 해제되고 운영체제로 반납된다.
- 부모는 다음과 같이 여러 가지 이유로 인하여 자식 중 하나의 실행을 종료할 수 있다.
  1. 자식이 자신에게 할당된 리소스를 초과하여 사용할 때, 이때는 부모가 자식들의 상태를 검사할 수 있는 방편이 주어져야 한다.
  2. 자식에게 할당된 태스크가 더 이상 필요 없을 때
  3. 부모가 exit를 하는데, 운영체제는 부모가 exit 한 후에 자식이 실행을 계속하는 것을 허용하지 않는 경우

<br>

- 몇몇 시스템에서는 부모 프로세스가 종료한 이후에 자식 프로세스가 존재할 수 없다.
- 그러한 시스템에서는 프로세스가 종료되면 그로부터 비롯된 모든 자식 프로세스들도 종료되어야 한다. 이것을 **연쇄식 종료(cascading termination)**이라 하며, 이 작업은 운영체제가 시행한다.
- **좀비(zombie) 프로세스** : 종료되었지만 부모 프로세스가 아직 wait() 호출을 하지 않은 프로세스
- **고아(orphan) 프로세스** : 부모 프로세스가 wait()를 호출하는 대신 종료할 때 부닥친 자식 프로세스

<br>
<br>
<br>
<br>

## References

[^1]: [위키백과 - 프로그램 카운터](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%B9%B4%EC%9A%B4%ED%84%B0)
[^2]: [[운영체제] 문맥교환(Context Switching) - 박연호](https://kosaf04pyh.tistory.com/195)