---
layout: single
title: "[DS] 분산 시스템(Distributed Systems) - 1. Introduction 정리"
excerpt: "Distributed Systems Third edition by Maarten van Steen,
Andrew S. Tanenbaum - cha1. Introduction 1.1, 1.2, 1.3, 1.4"
categories: DS
tags : [DS, 분산 시스템, 확장성, 투명성, 미들웨어, 컴퓨팅, grid, cluster, cloud, 인터페이스, distributed system, transparency, middleware]
toc: true
toc_sticky: true
sidebar_main: false

last_modified_at: 2023-04-25
---

<img align='right' width='200' height='200' src='https://user-images.githubusercontent.com/78655692/147719090-5f0942f1-1647-44ad-8d72-f11e3fe400d7.png
'>
본 글은 Distributed Systems 책의 내용을 개인 공부 목적을 위한 요약 및 정리한 내용입니다. <br> 오타나 오류는 알려주시길 바라며, 도움이 되길 바랍니다. <br> **2023.04.25 Update**
{: .notice--info}

**글을 읽으면서 스스로에게 물어보기 <br><br> 1. 왜 만들어 졌을까?(background, def) <br> 2. 왜 필요할까? (why?) <br> 3. 장점과 단점은 무엇인가? (adv, disadv)**
{: .notice--danger}

<br>
<br>
<br>
<br>


## Chapter 1. Introduction

- 1980년대에 이르러서부터 두 가지의 기술 발전이 상황을 바꾸었다.
  1. the development of `powerful microprocessors`
     - 8-bit machines -> 64-bit CPUs
     - 병렬 프로그램의 적응과 발전으로 다시 직면하고 있다.
     - 가격이 1/1000으로 싸졌다.
  2. the invention of `high-speed computer networks`
  - **LAN**(Local-area networks)으로 빌딩 안의 수천대의 장비들에게 정보를 마이크로초 단위로 전송이 가능해졌다. (공유기가 그 예이다.)
  - **WAN**(Wide-area network)로 몇백만대의 시스템들이 연결되어 bps 속도로 전송이 가능해졌다.
- 이러한 발전으로 우리는 소형 컴퓨터 시스템을 가질수 있게 되었다. 스마트폰 또한 하나의 결과물로 볼 수 있을 것이다.
- 센서, 메모리, 강력한 CPU로 채워진 이 장치들은 본격적으로 하기에 준비가 다 된 컴퓨터 못지 않다. (네트워크 능력도 가지고 있다.)
- 그래서 `plug computer`가 등장했다.
  > A **plug computer** is an external device, often configured for use in the home or office as a compact computer. The name is derived from the small configuration of such devices. [^1]
- 이런 기술들의 결과로 수많은 네트워크 컴퓨터들로 구성된 컴퓨팅 시스템을 구현할 수 있게 되었다. 이런 컴퓨터들은 지리적으로 분산되어졌는데 `distributed system`을 형성했다고 말할 수 있다.
- 이런 분산 시스템의 크기는 한 줌의 장치로부터 다양해졌다.
  - **시스템 (system)** : 하나의 공통적인 목적 수행을 위해 조직화된 요소들의 집합체 또는 체계 [^10]

<br>

### What is a distributed system?

- 분산 시스템(Distributed System)은 사용자에게 하나의 일관된 이미지(single system image)로 나타나는 자율 컴퓨팅 구성요소(component)의 집합이라 할 수 있다.
  - **single system image**란, 사용자에게 분산되어 있는 다수의 컴퓨터와 자원들을 하나의 통합된 시스템으로 보여주는 것을 말한다. 

<br>

### 특징1. Collection of autonomous computing elements

- 현대 분산 시스템은 높은 성능의 컴퓨터들부터 작은 플러그 컴퓨팅까지 많은 종류의 노드들로 구성되어 있다. 
  - **노드들은 서로 독립적으로 작동한다.** 
  - `nodes`: 독립적으로 움직이는 컴퓨팅 요소들 (하드웨어 장비나 소프트웨어 프로세스가 될 수 있다.)
  - **노드**: 컴퓨터 네트워크를 구성하는 기기 1대 [^2]
    - 독립적으로 작동하는 기기
    - 네트워크 또는 데이터 구조를 구성하는 각각의 객체
- 노드들은 메시지를 서로 교환하는 것을 구현하고자 하는 공동의 목표를 달성하기 위해 프로그램화 되어있다.
  - 노드는 들어온 메시지에 반응하고, 처리하고, 메시지 전달을 통해 더 많은 통신으로 유도한다.
  - **네트워크**(network) : 한 컴퓨터에서 다른 컴퓨터로 시그널(메시지)을 보내는 것
  - **라우팅**(routing) : 네트워크 상의 주소를 이용, 목적지까지 경로를 체계적으로 결정하는 경로선택 과정 (어떻게 보낼지 담당하는 역할) [^3]
- 각 노드는 각자 고유의 시간의 알림을 가지고 있다.
  - 따라서 **표준 시간(global clock)**이 없다.
  - 이 시간 참조의 결점은 분산 시스템에서 기능적 동기화(`synchronization`)와 조정 문제(`coordination`)를 유발하기도 한다.
- 노드들을 집합으로 처리하는 것은 그런 집합을 관리할 필요가 있음을 암시한다.
  - 즉, 노드들이 시스템에 속하는지 아닌지 등록해야 하며, 각각의 멤버에게 노드들의 직접 전달할 수 있는 리스트를 제공해야 한다.
- **group membership**을 관리하는 것은 승인 제어(`admission control`)의 이유 때문에 매우 어려울 수 있다.
  - 먼저 open group과 closed group를 구별해야 한다.
  - open group에서는 효율적으로 시스템에서 다른 노드에게 메시지를 전할 수 있게 어떤 노드도 분산 시스템에 합류하는 것을 허락해야 한다.
  - closed group에서는 이미 원래 멤버 서로 통신할 수 있고, 그 그룹에 합류와 떠나는 것에는 별도의 메커니즘이 필요하다.
- 승인 제어(`admission control`)의 어려움
  1. 노드를 인증하기 위한 메커니즘이 필요하다.
     - 인증을 관리하는 것은 확장성 병목 현상을 쉽게 만들어낸다.
  2. 각각 노드는 다른 그룹 멤버와 실제로 통신하는지 확인해야 한다.
  3. 멤버가 nonmember에게 쉽게 전달하는지 고려해봐야 한다. 
     - 분산 시스템에서 통신 이슈에 대해 신뢰성 즉, 메시지 유출 가능성을 따져본다.

<br>

### overlay network

- 분산시스템은 종종 **오버레이 네트워크(overlay network)**로 구성된다.
  - **오버레이 네트워크** : 물리 네트워크 위에 성립되는 가상의 컴퓨터 네트워크
    - P2P 네트워크와 같은 분산 시스템은 노드가 인터넷 상에서 실행되기 때문에 오버레이 네트워크에 해당한다. [^4]
- 이런 경우, 노드는 직접 메시지를 보낼 수 있는 소프트웨어 프로세스이다.
- 메시지 전달은 TCP/IP or UDP 채널을 통해 이뤄진다.
  - **TCP (Transmission Control Protocol)** : 신뢰성이 요구되는 애플리케이션에서 사용
  - **UDP (User Datagram Protocol)** : 간단한 데이터를 빠른 속도로 전송하는 애플리케이션에서 사용
  - **애플리케이션 (application)** : 다양한 범주의 정보처리 기능(컴퓨팅 작업) [^5]
- 두 가지 유형이 있다.
  - **Structured overlay** : 각 노드는 통신할 수 있는 잘 정의된 인접 노드 집합이 있다.
    - 노드들은 tree이거나 ring형으로 이뤄져 있다.
  - **Unstructured overlay** : 각 노드는 다른 노드들을 **랜덤하게** 선택되는 많은 참조를 가지고 있다.
- 어떤 경우든 오버레이 네트워크는 언제나 연결돼야 하는데,(구체적으로) 두개의 노드 간에는 반드시 서로 메시지를 전송하게 허용하는 통신 통로가 있다. 
- 잘 알려진 오버레이로는 `peer-to-peer` (P2P) 네트워크가 있다.

<br> 
<br> 

### 특징2. Single coherent system

- 분산시스템은 single coherent system으로 보여야 한다.
- single coherent system에서 노드들의 집합은 사용자와 시스템 사이에서 장소, 시간, 어떻게 작동하든지 간에 전체가 똑같이 작동한다.
- `single coherent`로 보이는 것은 어려울 수 있다.
  - 사용자는 어떤 프로세스가 현재 실행되는지 몰라야 한다.
    - **프로세스(process)**: 현재 실행 중인 프로그램
  - 데이터가 저장되는 위치는 문제가 되지 않아야 한다. 시스템은 성능을 높이기 위해 데이터를 복제할 수도 있다는 것도 문제가 되지 않아야 한다.
    - 이것을 **분산 투명성(distribution transparency)** 라 부른다.
    - 리소스는 파일이나, 저장 장치, 메모리, 네트워크 사이의 차이를 효과적으로 숨겨주는 **통합 파일 시스템 인터페이스**를 통해 접근한다는 유닉스의 운영시스템과 비슷한 접근이다.
      - **인터페이스**(interface) : 연결을 의미 (a와 b를 연결)
      - **인터페이스** : 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면
        - 사용자가 기기를 쉽게 동작시키는데 도움을 주는 시스템
        - 컴퓨팅에서 컴퓨터 시스템끼리 정보를 교환하는 공유 경계
- 하지만 `single coherent system`로 되게 하는 건 `trade-off`이다.
  - 분산시스템은 많은 네트워크 노드로 이루어져있기 때문에 시스템 고장을 피할 수는 없다.
  - `partial failure`은 복잡한 시스템에서 항상 발생하기 때문에 분산 시스템에서는 숨기기 어렵다.

> "one in which the failure of a computer you didn’t even know existed can render your own computer unusable"

<br>
<br>

### Middleware and distributed systems

- 분산된 애플리케이션의 발전을 돕기 위해, 분산 시스템은 논리적으로 각각의 컴퓨터의 운영체제 위에 위치한 분리된 계층을 가지며 구성된다.
  - **애플리케이션(application)**: 운영체제 위에서 사용자가 직접 사용하게 되는 소프트웨어 [^6]

<br>

![image](https://user-images.githubusercontent.com/78655692/150115611-ca99401f-fcc2-43d0-8d53-ac9baa31aeb6.png)

<br>

- 각각의 애플리케이션은 같은 인터페이스를 제공한다.
- **분산 시스템**은 단일 분산 애플리케이션의 컴포넌트들이 서로 통신할 뿐만 아니라, 서로 다른 애플리케이션 간의 통신을 허용하는 수단을 제공한다.
  - **컴포넌트 (component)** : 여러 개의 프로그램 함수들을 모아 하나의 특정한 기능을 수행할 수 있도록 구성한 작은 기능적 단위 [^7]
- 동시에, 이것은 각각 애플리케이션으로부터 하드웨어와 운영체제의 차이를 가능한 숨긴다.
- 어떤 맥락에선 미들웨어는 애플리케이션들에게 효과적으로 공유하고 이런 리소스들을 네트워크를 배포하는 것을 제공하는 리소스의 관리자 측면에서 분산시스템과 같다.
  - **미들웨어 (middleware)** : 서로 다른 여러 프로그램을 함께 운용할 수 있는 소프트웨어
- 리소스 관리자 뿐만 아니라 대부분 운영체제에서 볼 수 있는 서비스도 제공한다. 
  1. Facilities for inter-application communication
  2. Security services
  3. Accounting services (컴퓨터 리소스에 대한 로그 기록)
  4. Masking of and recovery from failures

- 운영체제와 다른점으로, 미들웨어 서비스는 네트워크 환경을 제공한다. 
- 어떤 의미에선, 미들웨어를 컴포넌트와 함수들을 공통적으로 사용하는 컨테이너로 볼 수 있다.
- 미들웨어는 컴포넌트와 애플리케이션들이 각각 실행되지 않게 도와주는 기능들로 사용되는 컨테이너로 볼 수 있다.

<br>

- 이같은 미들웨어 서비스의 예시들은 다음과 같다.

1. **Communication**
   - **RPC 서비스**를 사용하면 애플리케이션에서 원격 컴퓨터에서 마치 로컬에서 가능한 것처럼 구현되고 실행되는 함수를 호출할 수 있다.
     - **원격 프로시저 호출 (RPC, Remote Procedure Call)** : 별도의 원격제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게 하는 프로세스간 통신 기술
       - 원격 프로시저 호출을 이용하면 프로그래머는 함수가 실행 프로그램에 로컬 위치에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있다. [^8]
2. **Transactions**
   - 미들웨어로 **원자성 트랜잭션 (atomic transaction)**을 참조한다.
     - **트랜잭션 (transaction)** : 쪼갤 수 없는 업무 처리의 최소 단위
   - 응용 개발자는 원격 서비스를 불러오는 것만 명시하면, 표준 프로토콜을 가져오게 할 수 있고 미들웨어는 모든 서비스를 불러오거나 모두 안 불러올 수 있다.
3. **Service composition**
   - 웹기반 미들웨어는 웹 서버가 접근되고 함수를 생성하기 위한 수단을 제공하는 방식을 표준화함으로써 도와준다.
4. **Reliability**
   - 한 프로세스가 모든 프로세스에 의해 수신되거나 다른 프로세스가 수신되지 않도록 보장한다.
   - 이런 보장은 분산 애플리케션 개발을 단순화시며, 미들웨어의 한 부분으로 구현된다.

<br>
<br>

## 1.2 Design goals

- 분산 시스템은 리소스에 쉽게 접근할 수 있도록 해야 한다.
  - 리소스는 네트워크를 통해 분산되어 있다는 사실을 숨겨야 한다.
  - **open**되어야 하고, **scalable**되어야 한다.

<br>
<br>

### Supporting resource sharing

- 분산시스템의 중요한 목표는 **사용자가 원격 리소스를 쉽게 접근하고 공유할 수 있도록 만들어야 한다.**
  - **리소스(resources)**: 사용될 수 있는 어떤 항목
- 리소스를 공유하는 것은 경제성 이유에 있다.
- 인터넷 연결은 넓게 분산된 사람들이 같이 일할 수 있도록 허용해준다. 
- 분산 시스템에서 리소스 공유는 파일을 공유하는 P2P네트워크인 `BitTorrent`가 대표적인 예시이다.

<br>
<br>

### Making distribution transparent

- 분산 시스템의 중요한 목표는 프로세스와 리소스가 다중 컴퓨터를 통해 물리적으로 분산되어 있다는 사실을 숨겨야 하는 것이다.

<br>
<br>

### Types of distribution transparency

- **객체 (object)** : 프로세스 또는 리소스
- 분산 시스템에서 **transparency**란 분산 시스템 내부의 복잡한 동작과 상호작용을 추상화하여 사용자에게 투명하게 제공하는 것을 의미한다. 
- 분산 시스템에서 제공되는 transparency 종류는 다음과 같다.
  - **Access Transparency** : 데이터 표현의 차이를 숨기고 다양한 종류의 리소스에 일관된 방식으로 접근할 수 있다. 
    - 예를 들어, 분산 파일 시스템(예: HDFS)에서 사용자는 여러 대의 노드에 존재하는 파일들에 대해 하나의 파일 시스템으로 접근할 수 있다.
  - **Location Transparency** : 사용자가 리소스를 사용할 때 해당 리소스가 어디에 존재하는지에 대한 정보를 사용자에게 숨기고 추상화하여 제공한다. 
    - 예를 들어, URL이 있으며 실제로 관련 데이터들이 저장되어 있는 원격 데이터베이스가 물리적으로 어디에 위치했는지는 사용자에게 숨긴다.
  - **Relocation Transparency** : 프로세스나 데이터의 물리적인 위치가 변경되더라도 사용자나 애플리케이션은 이를 인식하지 못하게 하는 투명성을 말한다. 
    - 예를 들어, 서버의 IP 주소가 변경되더라도 클라이언트는 서버의 위치가 변경되었다는 것을 인식하지 않고 계속 서버에 접속할 수 있다.
  - **Migration Transparency** : 프로세스나 데이터가 한 시스템에서 다른 시스템으로 이동할 때 이를 사용자 애플리케이션이 인식하지 못하게 하는 투명성을 말한다. 
    - 예를 들어, 클라우드 컴퓨팅에서 가상머신이 한 호스트에서 다른 호스트로 이동할 때 이를 사용자가 인식하지 못하게 하는 것이다.
  - **Replication Transparency** : 데이터의 복제본을 여러 대의 서버에 저장하더라도 사용자나 애플리케이션이 이를 인식하지 못하게 하는 투명성을 말한다. 
    - 예를 들어, 분산 데이터베이스에서 데이터의 복제본이 여러 대의 서버에 저장되어 있을 때 사용자는 어떤 서버에서든 데이터에 접근할 수 있다.
  - **Concurrency Transparency** : 분산 시스템에서 여러 사용자가 동시에 리소스에 접근할 때, 이를 각각 독립적으로 수행하는 것처럼 보이도록 하는 것을 말한다. 
    - 예를 들어, 분산 데이터베이스에서 동시에 여러 클라이언트가 같은 데이터를 읽거나 쓸 때, 각 클라이언트는 자신이 해당 데이터를 독점적으로 사용하고 있는 것처럼 느끼게 된다. 
  - **Failure Transparency** : 분산 시스템에서 노드나 네트워크 장애가 발생할 때, 사용자가 이를 느끼지 못하게 하여 시스템의 신뢰성을 높이는 것을 말한다. 
    - 예를 들어, 데이터 복제를 이용하여 여러 노드에 데이터를 저장하면, 하나의 노드가 실패해도 데이터가 손실되지 않는다.

<br>
<br>

### Degree of distribution transparency

- 분산 시스템에서 분산 투명성은 보통 선호되지만 모든 분산 측면에서 숨기는 것은 유저에게 좋지는 않다.
- 투명성과 시스템 사이에 `trade-off`가 있다.
  - 다른 것을 시도하기 전에 일시적인 서버 장애를 가리는 것은 전체 시스템을 늦추게 한다.
- 다른 예로, 몇몇을 다른 대륙에 위치한 복제들을 동시에 일관성있게 하는 것이다.
  - 즉, 한 복제가 바뀌면, 다른 동작이 허용하기 전에 모든 복제본들에게 전파된다.
  - **redundancy (복제)** : 시스템 장애상황을 대비해서 중요한 시스템 구성요소를 복제
  - **replication (복제)** : 복제된 리소스의 데이터가 같아지도록 데이터를 공유
- 숨기는 것보다 노출하는게 더 좋을 수도 있는데, 지역 기반 서비스를 사용할 때가 그 예이다.

<br>
<br>

## Being open

- `open distributed system`은 다른 시스템으로 통합된 것을 쉽게 사용할 수 있게 컴포넌트들을 제공한다.
- **Interoperability(상호 운용성), Composability(결합성), Extensibility(확장성)**
- open이 되기 위해서, 컴포넌트들은 어떤 것을 제공해야될지 그것들의 문법, 의미를 설명하는 표준 규칙을 고수해야 한다.
- 일반적인 접근은 **IDL(Interface Definition Language)**를 사용하는 인터페이스를 통해 서비스를 정의하는 것이다.
  - 그들은 기능들의 이름을 정확히 명시한다.
- 명시가 잘 되었다면, 인터페이스 정의는 임의의 프로세스를 허용한다.
- 적절한 사양은 완전(실행하는데 필요한 모든 것이 명시되어야 한다는 것)하고 중립적이다.
- open distributed system이 되기 위해 다른 목표는 서로 다른 구성 컴포넌트로 시스템을 쉽게 구성할 수 있어야 한다.

<br>
<br>

### Separating policy from mechanism

- 오픈 분산 시스템에서 유연성을 얻기 위해서, 시스템이 작거나 쉽게 대체되고  적용가능한 컴포넌트들의 집합으로 구성되는 것은 중요하다.
- 웹 브라우저를 캐싱한다면 몇 가지 컴포넌트들이 고려되어야 한다.

  1. **Storage**
  2. **Exemption**
  3. **Sharing**
  4. **Refreshing**

<br>
<br>

## Being scalable

- **Scalability dimensions**
  1. **Size scalability** : 크기에 따른 확장성
     - 어떤 성능의 손실 없이 시스템에 유저나 리소스들을 쉽게 추가해야 된다.
  2. **Geographical scalability** : 거리에 따른 확장성
     - 유저와 리소스는 멀리 떨어져있지만 통신 지연은 거의 알아차리지 못한다.
  3. **Administrative scalability** : 관리에 따른 확장성
     - 많은 독립적인 관리 조직을 거친다 하더라도 쉽게 관리된다.

<br>
<br>

### Size scalability

- 시스템의 크기 즉, 노드의 수가 증가해도 선형적으로 처리 능력을 확장할 수 있는 것을 말한다. 
  - 새로운 노드를 추가하거나 기존 노드의 자원을 증설함으로써 크기를 확장할 수 있다.
- 유저나 리소스를 더 필요로 한다면 중앙 서비스의 한계에 직면한다.
  - 예를 들어, 많은 서비스들은 센서에 중앙되어 있어서 그들은 분산시스템에 단일 서버로 실행된다.
- 하지만 요청의 수가 증가하면 서버는 병목현상이 일어날 수 있다.
  - 병목현상이 될 수 있는 **3가지** 원인
    1. CPU 제한으로 인한 계산 용량
    2. 저장 용량 (I/O 전송 비율도 포함한다.)
    3. 유저와 중앙 서비스간의 네트워크

<br>
<br>

### Geographical scalability

- 분산 시스템이 지리적으로 분산된 위치에서 작동할 때 시스템 성능에 어떤 영향을 미치는지를 나타낸다.
  - 지리적으로 분산된 노드들을 연결하여 하나의 시스템으로 동작하게 만든다. 
- 지리 확장성을 갖춘 시스템은 물리적으로 떨어진 여러 지역에서 동일한 서비스를 제공할 수 있다.

<br>
<br>

### Administrative scalability

- 시스템 관리 비용을 최소화하면서 노드 수를 확장할 수 있는 것을 말한다. 
  - 노드 수가 증가해도 그에 따라 시스템 관리자의 인력 또는 비용이 증가하지 않도록 설계되어야 한다.
- 리소스 사용, 관리, 보안과 관련된 정책들이 충돌하는 것을 해결하려는 것이 주요 문제이다.
- 분산 시스템이 다른 도메인(domain)으로 확장한다면, 2가지 안전 유형이 고려되어야 한다.
  1. 분산 시스템은 새로운 도메인으로부터 악성 공격에 대해 방어한다.
  2. 새로운 도메인은 분산시스템으로부터 악성 공격에 대해 방어한다.
     - **도메인 (domain)** : 문자로 표시한 인터넷 주소
     
<br>
<br>

### Scaling techniques

- 분산 시스템에서 확장성 문제는 한정된 서버와 네트워크의 용량이 원인이다.
  - **scaling up**은 단일 시스템의 성능을 개선하여 시스템의 용량을 증가시키는 방법이다.
- 스케일 아웃(scaling out)에 의하면, 확장성을 향상시키기 위한 여러 방법들이 있다.
  - **scaling out**은 여러 대의 노드를 추가하여 시스템의 용량을 증가시키는 방법이며, 이를 통해 시스템의 가용성과 신뢰성을 높일 수 있다.

<br>

### 1. Hiding communication latencies

- latency는 시스템의 확장성을 제한하는 주요 요인 중 하나이다. 
- 이를 해결하기 위해 두 가지 전략이 존재하는데, 첫 번째는 메시지 전송과 수신 사이의 지연 시간을 최소화하는 것이다. 
- 두 번째로 지연 시간을 숨기는 것 즉, 데이터를 전송하면서 동시에 데이터를 처리하는 방식으로 통신 지연을 숨긴다. 
  - 이 방법은 비동기적인 I/O, 멀티스레딩, 비동기 콜백 등을 이용하여 구현될 수 있다.

<br>

### 2. Partitioning and distribution

- 대규모 분산 시스템에서는 데이터의 복제본을 여러 노드에 분산시키는 것이 중요하다. 
- 데이터를 파티셔닝하여 다수의 서버에 분산시키면 성능을 개선하고, 가용성과 신뢰성도 향상시킬 수 있다.
- 예시로는 **DNS** (Internet Domain Name System)가 있다.
  - **DNS** : 도인 이름에 대한 IP 주소를 등록하고 있으면서 도메인 이름에 대한 IP 주소를 알려주거나 IP 주소에 대한 도메인 이름을 알려주는 일을 담당
  - **IP 주소** : 인터넷에 연결된 기기를 식별하는 유일한 번호
- DNS 네임 공간은 위계적으로 구성되어 겹치지 않는 존으로 나뉘어져서 `domains`의 트리로 들어간다.
- 각 존의 네임들은 단일 네임 서버에 의해 관리된다. 

![image](https://user-images.githubusercontent.com/78655692/148327254-5ffaa947-7436-418b-96ce-9bdcc6923834.png)

<br>

- 또 다른 예시로는 `World Wide Web`이 있다.
- Web은 거대한 문서에 기반한 정보 시스템이며, 각 문서는 URL 형태로 고유 네임을 가지고 있다.
  - 마치 단일 서버에 있는 것처럼 보인다.
- 하지만 Web은 몇 백만의 서버를 거쳐 (각각의 서버는 많은 웹 문서를 관리한다.) 물리적으로 `partitioned and distributed`하다.
- 문서를 관리하는 서버의 네임은 문서의 URL로 인코딩된다.

<br>

### 3. Replication

- 확장성의 문제로 성능 저하가 보이면 분산 시스템에서 컴포넌트를 복제한다.
- **캐싱(cashing)**은 복제의 특별한 형태이다. 캐싱은 리소스를 복제하고 클라이언트가 리소스에 접근할 수 있도록 해준다.
  - **캐시** : 데이터를 임시로 저장해두는 장소 
  - 하지만 복제와 다르게, 캐싱은 클라이언트의 리소스를 결정한다.
- 하지만, 캐싱과 복제는 일관성 문제점이 있다.
- 어느 정도까지 불일치가 허용될 수 있는지는 리소스의 사용에 따라 크게 달라진다.
  - 강한 일관성의 문제점은 업데이트가 즉각적으로 다른 모든 복제본에게 전달되어야 한다는 점이다.
  - 두 개의 업데이트가 동시에 진행된다면, 업데이트는 어느곳이든 똑같은 순서로 진행되어야 하는데 전역 순서에서 문제가 생긴다.
- 그래서 복제는 전역 동기화 메커니즘이 필요하다. 하지만 이런 메커니즘은 상당히 구현하기 힘들다.

<br>
<br>

## 1.3 Types of distributed systems

### High performance distributed computing

- 클러스터 컴퓨팅에서 하드웨어는 빠른 스피드의 지역기반 네트워크들로 이루어진 비슷한 워크스테이션의 집합으로 이루어져 있다. 구체적으로 각 노드는 같은 운영 체제에서 실행한다.
  - **컴퓨터 클러스터(computer cluster)** : 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하는 컴퓨터들의 집합
  - **워크스테이션 (workstation)** : 많은 양의 데이터를 처리하는 작업에 최적화된 전문가용 PC
- 그리드 컴퓨팅과는 다른 케이스인데, 이 서브 그룹은 컴퓨터 시스템의 연합으로 구성된 분산 시스템으로 이루어져 있다.
- **그리드 컴퓨팅**의 관점에서 다음 논리적 단계는 단순히 컴퓨팅 집약적인 애플리케이션에 필요한 전체 인프라를 아웃소싱한다.
  - **아웃소싱** : 업무의 일부분을 전문기관에 위탁하는 것을 말한다.
- **클라우드 컴퓨팅**의 핵심은 인프라를 동적으로 구축하고 사용 가능한 서비스에서 필요한 것을 구성할 수 있는 기능을 제공한다.

<br>

- **DSM** (distributed shared-memory multi-computers) 시스템은 프로세스가 다른 컴퓨터의 메모리 위치를 마치 로컬 메모리인 것처럼 지정할 수 있다.

<br>
<br>

### Cluster computing

- 클러스터 컴퓨팅 시스템은 개인 컴퓨터와 워크스테이션의 낮은 가격과 성능이 향상되어 대중화되었다.
- 클러스터 컴퓨팅은 단일 프로그램이 다중 머신에 병렬로 실행되는 병렬 프로그래밍에 사용된다.

![image](https://user-images.githubusercontent.com/78655692/148669804-9f69d5ae-66a7-4328-babe-839f013c2781.png)

- 클러스터 컴퓨터의 예시로 그림처럼 리눅스 기반의 `Beowulf clusters`가 있다.
  - 각 클러스터는 마스터 노드에 의해 통제되고 접속되는 컴퓨터 노드들의 집합으로 구성된다.
  - 마스터는 노드들의 할당을 특정 병렬 프로그램으로 갈 수 있는 것을 다루고, 시스템의 유저들에게 인터페이스를 제공한다.
  - 계산 노드는 미들웨어 기능이 확장된 표준 운영 체제을 갖추고 있다.
- 클러스터 컴퓨팅의 특징으로는 **동질성(homogeneity)**이 있다.

<br>
<br>

### Grid computing

- 클러스터에서 컴퓨터들은 크게 같고, 같은 운영체제, 그리고 모두 같은 네트워크를 통해 연결되어 있다.
- 그리드 컴퓨팅에서 노드들은 어떤 특정한 작업을 위해 특별히 구성된다.
  - 그리드 컴퓨팅은 하드웨어, 운영 체제, 네트워크의 유사성에 관한 가정을 하지 않는다.
- 그리드 컴퓨팅은 다른 조직들의 리소스를 하나로 모아 다른 조직의 사람들의 협력을 허용한다.
  - 이러한 협력은 가상 조직(`virtual organization`)의 형태로 구현된다.
  - 같은 가상 조직의 속한 프로세스는 리소스의 접근 권한을 가진다.

<br>

![image](https://user-images.githubusercontent.com/78655692/148682490-74f30183-8a22-498d-8e9c-cebd27fa2655.png)

- `fabric layer`는 특정 장소의 로컬 리소스에 대한 인터페이스를 제공한다.
  - **레이어 (layer)** : 하나의 대상을 여러 개로 나눈 층
- `connectivity layer`는 그리드 트랜잭션을 지원하기 위한 통신 프로토콜로 이루어져 있다.
  - **프로토콜**(protocol)은 리소스 사이에 데이터를 전달하거나 원격 위치로부터 리소스에 접근하는데 필요하다.
    - **프로토콜** : 서로 다른 컴퓨터끼리 데이터를 원활하게 보내고 받기 위한 규칙
  - 연결 계층은 유저와 리소스를 인증하는 보안 프로토콜을 가지고 있다.
  - 유저로부터 프로그램에 권한을 위임하는 것은 `connectivity layer`에 중요한 기능이다.
- `resource layer`는 단일 리소스를 관리하는 것을 담당한다.
  - 이것은 연결 계층이 제공한 함수를 사용하고, 패브릭 계층에서 사용할 수 있는 인터페이스를 직접 호출한다.
  - 리소스 계층은 접근 제어를 담당하며, 연결 계층의 부분으로 수행되는 인증에 의존한다.
- `collective layer`는 **다중 리소스**의 접근을 처리하고, 리소스 발견, 할당, 다중 리소스에 관한 태스크의 스케줄링, 데이터 복제 같은 서비스들로 구성된다.
- `application layer`는 가상 조직에서 작동하고 그리드 컴퓨팅 환경에서 사용하는 애플리케이션들로 구성된다.

<br>
<br>

### Cloud computing

- 클라우드 컴퓨팅은 쉽게 사용할 수 있고 가상화 리소스 풀에 액세스할 수 있다.
- 클라우드 컴퓨팅은 보증이 **SLAs**(service-level agreements) 수단으로 제공되는 pay-per-use 모델에 기반한다.

<br>

![image](https://user-images.githubusercontent.com/78655692/148691345-a83ac37a-9c27-4f4a-94b7-bb15b4b9edd8.png)

<br>

- **Hardware** : 가장 낮은 계층은 필요한 하드웨어(프로세서, 라우터, 파워, 쿨링 시스템)를 관리하는 수단으로 형성된다.
  - 데이터 센터에서 실행되며, 유저들이 절대로 직접 볼 수 없는 리소스가 들어있다.
  - **프로세서(processor)** : 정보를 처리하는 요소/장치 (=`CPU`)
- **Infrastructure** : 이 층은 클라우드 컴퓨팅 플랫폼에서 가장 중요한 근본이다.
  - 유저들에게 가상 스토리지와 컴퓨팅 리소스로 구성된 인프라구조를 제공하기 위해 가상 기술을 배포한다.
  - 클라우드 컴퓨팅은 가상 스토리지 장치와 가상 서버들을 할당하고 관리하며 발전했다.
- **Platform** : 플랫폼 계층은 클라우드 컴퓨팅에 대해 운영 체제를 애플리케이션 개발자에게 제공(즉, 쉽게 개발하고 클라우드에서 실행을 필요로 하는 애플리케이션을 쉽게 배치할 수 있는 수단을)
  - 애플리케이션 개발자는 업로드와 공급업체의 클라우드에서 프로그램을 실행하는 호출들을 포함하는 vendor-specific API를 제공받는다.
  - **API (Application Programming Interface)** : 응용 프로그래머에서 사용 가능한 함수의 집합을 지정 [^11]
  - 이것은 실행가능한 파일을 운영 체제에게 실행될 수 있게 가져다 주는 유닉스의 `exec`와 같다.
  - 플랫폼 계층은 스토리지를 위한 높은 수준의 추상화를 제공한다.
  - Amazon S3 스토리지 시스템이 그 예이다.
- **Application** : 실제 애플리케이션들이 이 계층에서 실행된다.
  - office 365 제품들이 그 예이다. 이 애플리케이션들은 다시 한번 공급업체의 클라우드에서 실행된다.

<br>

- **Infrastructure-as-a-Service (IaaS)** : 하드웨어와 인프라 계층
- **Platform-as-a-Service (PaaS)** : 플랫폼 계층
- **Software-as-a-Service (SaaS)** : 애플리케이션들 

<br>
<br>

### Distributed information systems

- 네트워크 애플리케이션은 애플리케이션을 실행하고, 원격 프로그램(**client**라 부름)을 이용할 수 있게 해주는 서버로 구성된다.
  - 클라이언트는 서버에 특정 작동을 실행을 목표로 하는 요청을 보낸다.
    - **클라이언트(client)**: 네트워크를 통하여 서버라는 다른 컴퓨터 시스템 상의 원격 서비스에 접속할 수 있는 응용 프로그램이나 서비스 [^9]
    - 클라이언트(client)는 서비스 요구자, 서버(server)는 서비스 제공자

<br>
<br>

### Distributed transaction processing

- 데이터베이스에서의 동작은 트랜잭션(`transaction`)의 형태로 수행된다.
  - 트랜잭션을 사용한 프로그래밍은 기본 분산 시스템이거나 언어 런타임 시스템에 의해 공급되는 특별한 기본 컴포넌트들을 요구한다. 
- RPC는 트랜잭션에 캡슐화된다.

![image](https://user-images.githubusercontent.com/78655692/148694039-8ca6171f-2744-4587-a7cf-5a8a6389a3f8.png)

<br>

- `트랜잭션`은 ACID 특성들을 따른다.
  - **Atomic** : 외부 세계에서 트랜잭션은 불가분하게 일어난다.
  - **Consistent** : 트랜잭션은 시스템 불변성을 위반하지 않는다.
  - **Isolated** : 동시 트랜잭션은 서로 간섭하지 않는다.
  - **Durable** : 트랜잭션이 커밋하면, 그 변화는 영구적이다.
- 트랜잭션은 공동으로 중첩 트랜잭션을 형성하는 하위 트랜잭션으로 구성된다.
  - 성능을 얻거나 프로그래밍을 단순화하기 위해 상위 수준의 트랜잭션을 다른 곳에서 병행하며 실행되는 자식을 둘로 나눈다.
- 하위 트랜잭션은 미묘한 문제를 일으킨다.
  - 부모가 중단하면, 상위 수준의 트랜잭션이 시작하기 전에 전체 시스템을 스테이트로 복구해야 한다.
  - 커밋된 하위 트랜잭션의 결과는 실행이 취소되어야 한다.
  - 따라서 영속성은 최상위 수준의 트랜잭션에만 적용된다.

<br>

![image](https://user-images.githubusercontent.com/78655692/150288171-a950bb88-be93-46e2-a34b-a6ae52f96586.png)

<br>

- 중첩 트랜잭션은 분산시스템에서 중요한데, 다중 시스템을 통해 트랜잭션을 분산하는 방식을 제공하기 때문이다.
  - 그들은 원본 트랜잭션의 작업의 논리적 분할을 따른다.

![image](https://user-images.githubusercontent.com/78655692/150280849-07c3ee03-a2f9-4d10-ad94-742fe57e003b.png)

- **TP monitor** (transaction-processing monitor) : 트랜잭션 프로그래밍 모델을 제공함으로써 애플리케이션을 다중 서버/데이터베이스에 접근할 수 있도록 해준다.

<br>
<br>

### Enterprise application integration 

- 애플리케이션이 데이터베이스로부터 분리될수록, 설비가 필요하다는 것은 더욱 분명해졌다.

<br>

![image](https://user-images.githubusercontent.com/78655692/148694784-263815b6-3b47-4bf2-b228-7431527cc9d1.png)

<br>

- 몇가지 타입의 통신 미들웨어가 존재한다.
- **RPC**를 사용하면, 애플리케이션 컴포넌트가 효과적으로 요청을 다른 애플리케이션 컴포넌트에게 효과적으로 보내진다.
- **RMI(remote method invocations)**는 함수 대신 객체에서 작동하는 것을 제외하면 RPC와 본질적으로 동일하다.
- RPC와 RMI의 단점으로 호출자와 발신자 모두 (통신시에) 가동되어 실행되어야 한다는 점이다. 게다가 그들은 서로 어떻게 참조되어야 하는지 정확히 알고 있어야 한다.
- 이런 결함은 **MOM(message-oriented middleware)** 불러 왔다.
  - 애플리케이션은 메시지를 logical contact points에 보낸다.
  - 애플리케이션은 특정 유형의 메시지에 대한 관심을 나타낼 수 있으며, 그 후, 통신 미들웨어는 메시지들이 애플리케이션에 보내지는 것을 처리할 것이다.
  - 이런 `publish-subscribe` 시스템 형태는 중요해졌고 분산 시스템의 클래스로 확장되었다.

<br>
<br>

### Pervasive systems

- 안정성은 다양한 기술들(분산 투명성을 얻고자)을 통해 실현한다. 
- 하지만 모바일이나 임베디드 컴퓨팅 장치들이 바뀜에 따라 `pervasive systems`로 불리는 것들이 나왔다.
- 퍼베이시브 시스템은 우리 주변에 자연스럽게 섞이기 위한 것이다.
  - 퍼베이시브 시스템은 사용자의 행동에 대한 다양한 측면을 파악하는 많은 센서들을 갖추고 있다.
    - **센서 (sensor)** : 물리적인 환경 정보의 변화를 전기적 신호로 바꿔주는 기계 장치
  - 마찬가지로, 이것은 정보와 피드백을 제공하기 위함과 행동을 조종하기 위해서 무수한 **액추에이터**를 가지고 있다. 
    - **엑추에이터 (actuator)** : 전기적 신호를 빛, 소리 등 물리적 변화로 바꿔주는 기계 장치 (=작동기)
- 퍼베이시브 시스템 속의 많은 장치들은 작아지고, 배터리화, 모바일, 무선 연결 등이 특징이다. (Internet of Things라 불리는 그들의 역할)

<br>
<br>

### Ubiquitous computing systems

- 이 시스템은 pervasive하며 일어나고 있다는 것을 자각하지 못할 정도로 연속적으로 존재한다.
- **특징**
  1. **Distribution** : Devices are networked, distributed, and accessible in a transparent manner.
     - 장치와 다른 컴퓨터는 네트워크되고 같이 작동(단일 시스템같게 형성)한다.
  2. **Interaction** : Interaction between users and devices is highly unobtrusive.
     - 유비쿼터스 컴퓨팅은 보기에 인터페이스를 숨긴 것이라 말할 수 있다.
     - 예를 들어, 차의 좌석이 있으면, 밥이 앉았다는 것을 시스템은 알아차리고 그에 적절한 반응을 할 것이다. 여기에 엘리스도 이용한다는 것을 생각해 본다. 
  3. **Context awareness** : The system is aware of a user’s context in order to optimize interaction.
     - 유비쿼터스 컴퓨팅 시스템이 해야 할일은 상호작용이 일어나는 문맥을 고려하는 것이다.
  4. **Autonomy** : Devices operate autonomously without human intervention, and are thus highly self-managed.
     - 유비쿼터스 컴퓨팅 시스템의 중요한 측면으로 명시적 시스템 관리가 최소한으로 줄어들었다는 점이다.
     - 시스템은 자율적으로 행동하고, 자동으로 변환에 반응한다.
  5. **Intelligence** : The system as a whole can handle a wide range of dynamic actions and interactions.
     - 유비쿼터스 컴퓨팅 시스템은 방법과 기술(인공지능 분야로부터)을 사용한다.

<br>
<br>

### Mobile computing systems

- `mobility`는 퍼베이시브 시스템의 중요한 컴포넌트인데 모바일 컴퓨팅에 적용 해 볼것이다.
- 몇가지 이슈들이 있다.
  - 모바일 시스템의 부분을 형성한 장치는 매우 광범위하다.
    - 전혀 다른 타입의 장치들은 통신하는데 IP를 쓰고 있다. 
    - 이러한 장치들은 원격 제어, 페이저, 배지, 차 구성, 다양한 GPS 장치를 포함하고 있다.
  - 모바일 컴퓨팅에서 장치의 위치는 시간이 지남에 따라 변한다는 것이다.
    - 위치가 변하는 것은 통신에 지대한 영향을 끼친다.


<br>
<br>

### Sensor networks

- 센서 노드는 감지된 데이터(애플리케이션 방식으로)를 효율적으로 처리하기 위해 협력한다.
- 센서 네트워크는 하나 이상의 센싱 장치를 갖춘 수백만의 작은 노드들로 구성된다.
  - 또한 노드는 액츄에이터로 활동한다.

<br>

![image](https://user-images.githubusercontent.com/78655692/148698298-a9682274-5bc8-4bf6-b050-1280fc121df4.png)

<br>

- 위 그림의 첫번째는 센서들은 협력하진 않지만 그들의 데이터를 오퍼레이터의 위치에 자리한 중앙 데이터베이스에 보낸다.
- 두번째 극단적인 그림은 쿼리를 관련 센서에 전달하고 각각이 응답을 계산하고, 운영자가 응답을 집계하도록 한다.
- 위 방법들 모두 좋지는 않다.
  - 첫번째는 센서들이 모든 측정된 데이터를 네트워크를 통해 보내야 하는데, 이것은 네트워크 리소스와 에너지를 낭비한다.
  - 두번째도 센서들(조금의 데이터를 운영자에게 반환한다)의 집계 능력을 버리므로 낭비이다.

<br>
<br>
<br>
<br>

## References

[^1]: [wikipedia - Plug computer](https://en.wikipedia.org/wiki/Plug_computer)
[^2]: [[네트워크] 노드(node)란? - 두더지 개발자](https://engineer-mole.tistory.com/141)
[^3]: [정보통신기술용어해설 - Routing   라우팅, 루팅, 중계방식](http://www.ktword.co.kr/test/view/view.php?nav=2&no=539&sh=%EB%9D%BC%EC%9A%B0%ED%8C%85)
[^4]: [해시넷 - 오버레이 네트워크](http://wiki.hash.kr/index.php/%EC%98%A4%EB%B2%84%EB%A0%88%EC%9D%B4_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)
[^5]: [정보통신기술용어해설 - Application Layer   응용 계층, 어플리케이션 계층](http://www.ktword.co.kr/test/view/view.php?nav=2&no=468&sh=%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98)
[^6]: [해시넷 - 응용 소프트웨어](http://wiki.hash.kr/index.php/%EC%9D%91%EC%9A%A9_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)
[^7]: [해시넷 - 컴포넌트](http://wiki.hash.kr/index.php/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8)
[^8]: [해시넷 - 원격 프로시저 호출](http://wiki.hash.kr/index.php/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C)
[^9]: [해시넷 - 클라이언트 (컴퓨팅)](https://ko.wikipedia.org/wiki/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8_(%EC%BB%B4%ED%93%A8%ED%8C%85))
[^10]: [정보통신기술용어해설 - System   시스템](http://www.ktword.co.kr/test/view/view.php?nav=2&no=4433&sh=blocking+system)
[^11]: [2.3 시스템 호출(system call) - pwnpwnhnpwn](https://pwnkidh8n.tistory.com/118)