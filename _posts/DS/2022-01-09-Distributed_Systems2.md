---
layout: single
title: "분산 시스템(Distributed Systems) - Architectures"
excerpt: "Distributed Systems Third edition by Maarten van Steen,
Andrew S. Tanenbaum - cha2. Architectures 2.1, 2.2, 2.3, 2.4"
categories: DS
tag : [DS]
toc: true
toc_sticky: true
sidebar_main: true

last_modified_at: 2022-01-20
---

<img align='right' width='200' height='200' src='https://user-images.githubusercontent.com/78655692/147719090-5f0942f1-1647-44ad-8d72-f11e3fe400d7.png
'>
본 글은 Distributed Systems 책의 내용을 개인 공부 목적을 위한 요약 및 정리한 내용입니다. <br> 번역보다는 직역을 통해 영문책을 이해하려다 보니 단어나 문장이 다소 어색할 수 있습니다. <br>  영어문장에 맞게 최대한 이해하려 했습니다. 가지치기($\nearrow$)로 꾸며주는 말을 따로 빼서 육하원칙, 지칭 등을 넣어 해석했습니다. <br>오타나 오류는 알려주시길 바라며, 도움이 되길 바랍니다.
{: .notice--info}

<br>
<br>
<br>
<br>

## Chapter 2. ARCHITECTURES

- 분산시스템의 조직은 소프트웨어(시스템을 구성하는) 요소이다.
- 이런 소프트웨어 아키텍처를 얼마나 다양한 소프트웨어 컴포넌트가 이뤄졌는지와 어떻게 협력하는지를 말할 것이다.
  - **소프트웨어 아키텍처** : 컴포넌트 단위로 기능을 나눴는데 컴포넌트끼리 협력을 어떻게 하느냐
- 분산 시스템의 중요한 목표는 미들웨어 계층을 제공하는 플랫폼으로부터 어플리케이션을 분리하는 것이다.
  - 이러한 계층을 쓰는 것은 중요한 아키텍처 결정이며, 분산 투명성을 제공하는 것이다.

<br>

## 2.1 Architectural styles

- 아키텍처 스타일은 컴포넌트들로 형성된다. $\nearrow$ (컴포넌트들은) 서로 연결되고 데이터는 컴포넌트들 사이에서 교환되며, 이런 요인들이 시스템으로 구성된다.
- 컴포넌트 (`component`)는 잘 정의된 모듈식 단위이다. $\nearrow$ (단위는) 필수 및 제공 인터페이스를 가진 $\nearrow$ (인터페이스는) 이런 환경에서 교체 가능한
  - 요소가 특히 시스템이 실행될 때 교체될 수 있어야함은 중요하다.
- **커넥터 (connector)**는 컴포넌트 간의 통신, 협력을 중재하는 매커니즘이다.
  - 커넥터는 요소들 간의 제어와 데이터의 흐름을 허용한다.
- 요소와 커넥터를 사용하여 다양한 구성을 만들 수 있으며, 이는 아키텍처 스타일을 분류하게 되었다.
  - `Layered architectures`
  - `Object-based architectures`
  - `Resource-centered architectures`
  - `Event-based architectures`

<br>

## Layered architectures

- 컴포넌트들이 레이어드 방식으로 구성되어 있다. $\nearrow$ (레이어드 방식은) $L_j$에 있는 컴포넌트가 낮은 레벨에 있는 컴포넌트 $L_i$에게 다운콜하고 응답을 기대하는
  - 특출난 케이스가 하이레벨 컨포넌트로 업콜 할 때이다.

<br>

![image](https://user-images.githubusercontent.com/78655692/148709612-705ee8d0-0818-470f-bb0f-9e201ed9c5d4.png)

<br>

- (a)는 표준 구조(다음 하위 계층에 대해 다운콜만 수행되는)를 보여준다.
  - 이 구조는 네트워크 통신에 주로 보인다.

<br>

### Layered communication protocol

![image](https://user-images.githubusercontent.com/78655692/148709840-6813bd39-f7ba-434f-a76d-7ff0be970a78.png)

<br>

- 통신-프로토콜 스택에서 각 계층은 하나 또는 몇몇의 통신 서비스를 실행한다. $\nearrow$ (통신 서비스는) 데이터를 목적지로 보내는 것을 허용하는
- 이를 위해 각 계층은 인터페이스를 제공한다. $\nearrow$ (인터페이스는) 요청될 수 있는 함수를 명시함
- **프로토콜 (protocol)**은 당사자들이 정보 교환을 위해 따라야 하는 규칙을 말한다.
- 차이점들을 아는 건 중요하다. $\nearrow$ (어떤?) **서비스**는 계층에 의해 제공되고, **인터페이스**는 서비스가 이용할 수 있게 해 주고, **프로토콜**은 계층이 통신을 수립하기 위해 실행한다는 것을
- **TCP(; Transmission Control Protocol)**는 메시지가 연결 설정 또는 해제를 위해 교환되는 것을 명시하며, 이는 전송된 데이터의 순서를 보존하기 위해서 필요로 하며, 데이터(전송하는 동안 잃어버렸던)를 감지하고 바로잡기 위해서도 그 이유이다.

<br>

- `Two communicating parties`

```python
from socket import *

# A simple server
s = socket(AF_INET, SOCK_STREAM) # 소켓 = 연결을 위한 출입구
(conn, addr) = s.accept() 
while True:
    data = conn.recv(1024)
    if not data: 
        break
    conn.send(str(data)+'*')
conn.close()

# A client
s = socket(AF_INET, SOCK_STREAM)
s.connect((HOST, PORT))
s.send('Hello, world')
data = s.recv(1024)
print data
s.close()
```

- `socket()` : to create an object representing the connection
- `accept()` : a blocking call to wait for incoming connection requests; if successful, the call returns a new socket for a separate connection
- `connect()` : to set up a connection to a specified party
- `close()` : to tear down a connection
- `send(), recv()` : to send and receive data over a connection, respectively


<br>
<br>

### Application layering
 
- `The application-interface level`
- `The processing level`
- `The data level`

<br>

- 애플리케이션은 대략 세가지 부분으로 구성돼 있다.
  - 1) 사용자나 외부 애플리케이션과의 상호작용을 처리하는 부분, 2) 데이터베이스나 파일시스템에서 작동하는 부분, 3) 어플리케이션의 핵심 기능들을 포함하는 중간 지점
  - 중간 부분은 프로세싱 레벨에 *논리적으로* 위치해 있다.
- *프로세싱 부분에 대한 예제1.* 인터넷 검색 엔진 
  - 유저는 문자를 치면 웹페이지의 제목 목록들이 보여질 것이다.
  - 백엔드는 웹 페이지(프리패치되고 인덱스되는)의 거대한 데이터베이스에 의해 형성된다.
  - **검색 엔진**의 핵심은 키워드의 유저의 문자를 하나 혹은 다른 데이터베이스 쿼리로 전송하는 프로그램이다.
  - 그 후에 결과들이 리스트로 랭크되고, 리스트를 HTML 페이지에 전송한다.
  - 정보 회수 파트는 프로세싱 수준에 있다.

    ![image](https://user-images.githubusercontent.com/78655692/148915278-47e23286-a77a-4424-9255-4896d45ba750.png)

<br>

- *프로세싱 부분에 대한 예제2.* 부동산 중개업을 위한 의사결정 시스템
  - 3가지 구성요소
    - 유저 인터페이스를 실행하거나 프로그래밍 인터페이스를 외부 어플리케이션에 제공하는 프론트엔드
    - 금융 데이터가 있는 데이터베이스에 접근을 위한 백엔드
    - 이런 2개 사이의 분석 프로그램
  - 금융 데이터를 분석하는 것은 통계적 메서드와 통계와 인공지능으로부터의 기술을 요구한다.
  - 그래서, 금융 의사결정 지원 시스템의 핵심은 처리량과 유저로부터의 응답을 얻기 위해 고성능 컴퓨팅의 실행을 필요로 한다.
- *프로세싱 부분에 대한 예제3.* office 365는 통합 문서 관리를 지원하고, 유저의 홈 경로로부터의 파일들을 실행시켜주는 공통 유저 인터페이스를 통해 통합된다.
  - 프로세싱 레벨은 프로그램의 큰 집합으로 구성되어 있다.

<br>

- 데이터 수준(data level)은 애플리케이션이 작동하는 곳에서 실제 데이터를 유지하는 프로그램을 포함한다.
  - 데이터는 애플리케이션이 실행되고 있지 않더라도 지속적이여서, 데이터는 다음 유저를 위해 어느 곳에 저장될 것이다.
  - 데이터 수준은 다른 애플리케이션을 거칠 때 데이터 일관성을 지켜야 하는 책임이 있다.

<br>
<br>

## Object-based and service-oriented architectures

![image](https://user-images.githubusercontent.com/78655692/148978947-7f2613a9-0f09-4787-bb22-f39e4aee889a.png)

- 각 객체는 컴포넌트라 정의한 것과 일치하며, 이런 컴포넌트들은 프로시저 호출 방식을 통해 연결되었다.
- 객체기반 아키텍처는 캡슐화하는 방식을 제공한다. $\nearrow$ (어떤 걸?) 데이터(=객체의 state)와 데이터에 수행되는 동작(=객체의 method)을 단일 엔티티로 캡슐화
  - **캡슐화 또는 인캡슐레이션(encapsulation)** : 객체의 데이터와 기능을 하나로 묶고 외부에 노출되지 않도록 숨김 처리하는 것 (데이터 보호)
- 객체에 의해 제공된 인터페이스는 실행의 세부 사항들을 숨긴다.
- 인터페이스가 잘 정의되어 있고, 다른 부분은 건드리지 않는다면, 객체는 정확히 같은 인터페이스로 대체되어야 한다.
- 인터페이스와 이런 인터페이스를 실행하는 객체 간의 분리는 장치에 있는 인터페이스를 두게 허용하며, 객체 본래는 다른 장치에 있게 한다. (**분산 객체**(distributed object라 한다.)

<br>

![image](https://user-images.githubusercontent.com/78655692/149040992-ddb1cef8-58b2-44bf-9932-8640b2c2e4d0.png)

<br>

- 클라이언트가 분산 객체를 묶을때, 객체의 인터페이스(=`proxy`)의 실행은 클라이언트의 주소 공간으로 로드된다.
- **proxy**는 RPC 시스템의 클라이언트 스텁과 유사하다.
- 프록시는 오직 메시지로의 마샬 메서드 호출과 메서드 호출의 결과를 클라이언트로 반환하기 위한 언마샬 응답 메시지만 받을 수 있다.
  - **프록시 (proxy)** : 컴퓨터 네트워크에서 다른 서버 상의 자원을 찾는 클라이언트로부터 요청을 받아 중계하는 서버 
- **마샬링**(marshalling) : 객체의 메모리 표현을 스토리지 또는 전송에 알맞는 데이터 포맷으로 변형의 프로세스이다.
- 수신 호출 요청이 먼저 서버 스텁으로 가면, 그들을 서버의 객체의 인터페이스에 있는 메서드 호출을 만들기 위해 언마샬한다.
- **서버 스텁**(server stub)은 응답을 마샬링하고, 클라이언트측 프록스에게 응답 메시지를 보내는 일을 담당한다.
- 서버측 스텁(=`skeleton`)은 서버 미들웨어가 user-defined 객체를 통과하기 위한 수단을 제공한다.

<br>

- 대부분의 분산 객체들은 스테이트가 분산되어 있지 않다.
  - 이것은 단일 시스템에 상주한다.
  - 분산 객체에서 스테이트 본래 물리적으로 다중 시스템으로 분산되어 있지만, 이런 분산은 또한 객체의 인터페이스 뒤에 있는 클라이언트로부터 숨겨져 있다.
- 객체기반 아키텍처는 캡슐화 서비스가 독립적인 유닛에 들어가는 토대를 형성한다.
- 독립적으로 작동하는 다양한 서비스들을 분리함으로써, 우리는 서비스기반 아키텍처(SOAs; service-oriented architectures)로 갈 수 있게 되었다.

<br>
<br>

## Resource-based architectures

- 웹 너머로 서비스의 수가 증가와 서비스 구성을 통한 분산시스템의 발달이 더 중요해짐에 따라, 연구자들은 웹기반 분산 시스템의 아키텍처를 다시 생각해보기로 했다.
- 서비스 구성의 문제점 중 하나는 다양한 컴포넌트를 연결하는 것이 통합 악몽(nightmare?)이 될 수 있다는 점이다.
- 대안으로 분산 시스템을 거대한 리소스(각각이 컴포턴트로서 관리되는)의 집합으로 보는 것이다.
- 리소스들은 (원격) 애플리케이션에 의해 추가되거나 제거되고, 검색 또는 수정된다.
- 이런 접근이 지금은 웹에 널리 채택되었고, REST(; Representational State Transfer)로 알려졌다.
- RESTful 아키텍처의 4가지 특징이 있다.
  1. 리소스들은 단일 이름 스키마를 통해 확인한다.
      - **스키마**(scheme) = 규칙, 원칙, 철학
      - **이름 스키마**(naming scheme) : 이름을 붙일 때 어떤 규칙을 가지고 붙임
  2. 모든 서비스는 같은 인터페이스(많아 봐야 4가지 작동으로 구성된)를 제공한다.

    ![image](https://user-images.githubusercontent.com/78655692/149076180-53df2347-ce54-4d72-8c17-0be0a22e7e5d.png)
  3. 서비스로부터 보낸 메시지들은 self-described이다.
  4. 서비스에서 동작을 실행한 후에, 컴포넌트는 요청자에 대해 모든 걸 잃어버린다.(=`stateless execution`)
- RESTful은 **Amazon S3**(Amazon's Simple Storage Service)같은 클라우드 스토리지 서비스를 생각해본다.
- Amazon S3는 오직 두가지 리소스를 지원한다.
  1. `object` : 파일(file)
  2. `bucket` : 디렉토리(directory)
- BucketName에 포함된 ObjectName 객체는 URL을 통해 참조된다.
  - ex. `http://s3.amazonaws.com/BucketName/ObjectName`
- bucket이나 object을 생성하기 위해서는 애플리케이션이 bucket/object의 URL과 함께 PUT 요청을 보내야 한다.
- 이것은 HTTP 요청이 S3에 의해 해석될 것이다.
  - 버킷이나 객체가 이미 존재한다면, HTTP 에러 메시지가 반환된다.
- RESTful 아키텍처는 **단순함**때문에 인기있어졌다.
  - 이런 단순함은 쉬운 해결이 복잡한 통신 스키마로 가는 것을 막는다.
  - 하지만 무수히 많은 서비스 인터페이스는 문제를 야기한다.

<br>
<br>

## event-based coordination

### Publish-subscribe architectures

- 시스템이 꾸준히 성장하고 프로세스들이 쉽게 합류하거나 떠나는 게 가능해지면서, 프로세스 간의 의존성이 느슨해지는 아키텍처를 가지는 것은 중요해졌다.
- 큰 분산 시스템 클래스는 아키텍처(프로세싱과 조정(coordination) 간의 강한 분리)를 채택했다.
  - 시스템을 독립적으로 작동하는 프로세스들의 집합으로 보는 것이다.
  - **조정 (coordination)**은 프로세스 간의 통신과 협력을 말한다.
    - `coordination` : 여러 노드 사이에서 벌어지는 일에 대해서 뭔가를 조정
    - 이것은 프로세스에 의해 수행되는 활동들이 전체로 묶여지는 결합(glue?)을 형성한다.

    ![image](https://user-images.githubusercontent.com/78655692/149267509-f7397466-5d39-48f5-8a6a-b2db9697fefb.png)

  - **direct coordination**
    - 프로세스가 시간 결합되고 참조 결합(referentially coupled)되어 있다면, coordination은 직접 일어난다.
    - 참조 결합은 통신에서 명시적인 참조의 형태로 나타난다.
    - 시간 결합은 통신하는 과정이 모두 가동되고 실행되어야 한다는 것을 의미한다.
  - **mailbox coordination**
    - 프로세스가 시간적으로 분리되지만 참조 결합일 때
    - 통신 프로세스가 동시에 실행될 필요가 없다. 대신에 통신은 메시지를 메일 박스에 넣음으로써 발생한다.
  - **event-based coordination**
    - 참조 결합이 분리되고 시간 결합일 때
    - 참조 분리 시스템에서는 프로세스들은 명시적으로 서로 알지 못한다.
      - 프로세스가 유일하게 할 수 있는 건 이벤트의 현상을 나타내는 알림을 publish받는 것이다.
      - 모든 종류의 알림이 온다면, 프로세스는 특정 종류의 알림을 subscribe해야 한다.
  - **shared data space**
    - 프로세스들은 전부 튜플(tuple)을 통해 통신한다.
    - 튜플을 검색하기 위해, 프로세스는 튜플에 맞는 검색 패턴을 제공한다.
  - 공유 데이터 공간은 가끔 이벤트 기반 조정과 결합된다.
    - 프로세스는 검색 패턴을 제공함하여 특정 튜플을 구독한다.

    <br>

    ![image](https://user-images.githubusercontent.com/78655692/149273849-7f1317f2-c6be-40ee-8066-519d4a3a99fb.png)

- description이 `(attribute, value)`로 구성된다면 **topic-based publish-subscribe systems**이라 부른다.

<br>

![image](https://user-images.githubusercontent.com/78655692/149275075-781adbb1-dbf6-4633-9ee2-a093324b0c0b.png)

<br>

  - 구독은 알림에 대해 매치되어야 한다.
  - 이벤트는 실제로 이용가능한 데이터에 해당한다.
  - 매칭이 성공하면, 두가지 시나리오가 있다.
    1. 미들웨어는 발행된 알림(관련 데이터와 함께)을 보내는 것을 결정한다.
    2. 미들웨어는 구독자가 읽기 동작을 실행해 관련 데이터를 검색할 수 있는 알림지점을 보낸다.

  - 저장은 별도 서비스에 의해 관리되거나 구독자의 몫이다.
    - 다시 말해, 참조 분리이지만 시간 결합 시스템을 가지고 있다.

<br>

- 이벤트는 구독 처리를 쉽게 복잡하게 만든다.
- 중요한 이슈는 효율적이고 확장 가능한 실행(구독을 알림으로 매칭하는)이다.
- 발행-구독 아키텍처는 아주 큰 규모의 분산 시스템을 쌓는데에(강한 프로세스 분리때문에) 많은 가능성을 제공한다.

<br>
<br>

## 2.2 Middleware organization

- 미들웨어의 조직에 적용되는 디자인 패턴의 2가지 중요한 타입으로 `wrapper`와 `interceptor`가 있다.
  - 각각은 다른 문제를 목표로 하지만 미들웨어에 같은 목표(openness 얻는 것)를 보낸다.

<br>
<br>

### Wrappers

- 기존 컴포넌트로 분산 시스템을 구축할 때, 근본적인 문제가 생긴다. : 레거시로 제공되는 인터페이스는 모든 애플리케이션에 적용되지 않는다는 것
- **wrapper**나 **adapter**는 인터페이스(이것의 기능들을 컴포넌트에서 가능한 곳으로 전송한다)를 클라이언트 애플리케이션에 접근가능하게 해주는 특별한 컴포넌트이다.
- `object adapter`는 애플리케이션이 원격 객체를 호출할 수 있는 컴포넌트이다. (이런 객체들이 관련 데이터베이스의 테이블에서 동작하는 라이브러리의 결합으로써 실행된다 할지라도)
- 아마존 S3 스토리지 서비스는 RESTful 아키텍처, 기존 접근을 따르는 2타입의 가능한 인터페이스가 있다.
  - RESTful 인터페이스를 위해, 클라이언트는 HTTP 프로토콜을 사용하게 되는데, 기존 서버(실제 스토리지 서비스의 어댑터 역할을 하는)와 본질적으로 통신하는, 들어오는 요청을 부분적으로 나누고 결과적으로 그들을 S3의 특수 서버 내부에 넘겨준다.
- `wrapper`는 기존 컴포너트를 가지고 시스템을 확장하는데 중요한 역할을 한다.
  - **래퍼 (wrapper)** : 활동범위를 설정하고 좀더 중요한 다른 프로그램의 실행을 가능하게 하는 프로그램이나 스크립트 [^1]
  - 개방성을 달성하는데 중요한 확장성은 필요하면 wrapper를 추가해 보내지곤 했다.
  - 다시 말해, 애플리케이션 A가 애플리케이션 B가 필요로 했던 데이터를 관리했다면, B에 특화된 wrapper를 개발하여 A 데이터에 접근할 수 있도록 하는 것이다.
    - N 애플리케이션이 있다면 $N \times (N-1) = O(N^2)$ wrapper를 개발해야 한다.
- wrapper의 수를 줄이는 건 미들웨어를 통해 행해진다.
  - 논리적으로 컴포넌트(다른 애플리케이션 간의 모든 액세스를 다루는)가 집중화된 **브로커**(broker)를 실행한다.
  - 브로커가 각각 애플리케이션에게 단일 인터페이스를 제공하기 때문에 우리는 $O(N^2)$ 대신에 많아봐야 $2N = O(N)$가 필요할 뿐이다.

<br>

![image](https://user-images.githubusercontent.com/78655692/149450604-e1ad3b47-3319-45d3-ad97-a04a0a1a7fa1.png)

<br>
<br>

### Interceptors

- 개념적으로 인터셉터(interceptor)는 제어의 일반적인 흐름을 깨고 다른 코드가 실행될 수 있도록 하는 소프트웨어 구조일 뿐이다.
- 인터셉터는 미들웨어를 애플리케이션의 특정한 필요로부터 적용하는데 주요 수단이다.
  - 따라서 인터셉터는 미들웨어를 open하는데 중요한 역할을 한다.
  - 인터셉터를 포괄적으로 만드는 것은 상당한 실행 노력이 필요할 것이며 이러한 경우 일반화가 제한된 애플리케이션과 단순함보다 좋다고 말하는 것은 확실치 않다.
  - 또한, 많은 경우 오직 제한된 인터셉터를 가지는 것은 소프트웨어 관리와 분산시스템을 향상시킬 것이다.

<br>

![image](https://user-images.githubusercontent.com/78655692/149452565-a2326416-7bb5-4319-b028-6c397f179e36.png)

<br>

- `request-level interceptor`이 하는 일은 각각의 복제에게 호출을 요청할 것이다.
  - 요청 수준 인터셉터(미들웨어에 추가될 수 있는)만이 B의 복제를 알 수 있다. 
- 마지막에는, 원격 객체에서의 요청은 네트워크 너몰 보내질 것이다.
- 실제로, 메시징 인터페이스(지역 운영 시스템에 의해 제공되는)는 요청을 필요로 할 것이다.
  - 이 수준에선, `message-level interceptor`는 호출을 목표 객체로 전송하는 것을 도와준다.

<br>
<br>

### Modifiable middleware

- wrapper와 interceptor를 제공하는 것은 미들웨어를 확장하고 조정하는 수단이다.
  - 조정의 필요성은 분산 애플리케이션이 변화가 연속적으로 실행되는 환경으로부터 온다.
- modifiable middleware는 미들웨어는 조정할 필요가 있을 뿐 아니라, 이것을 중단하지 않고 의도적으로 수정할 수 있어야 하는 것으로 표현했다.
  - 인터셉터는 제어의 표준 흐름을 조정하는 수단을 제공한다.
- 컴포넌트 기반 디자인은 구성을 통해 수정가능성을 지원하는 데 집중한다.

<br>
<br>

## 2.3 System architecture

- 이제는 어떻게 많은 분산 시스템이 소프트웨어 컴포넌트들이 어디에 배치되는지 고려하여 실제로 구성되는지 본다.
- 소프트웨어 컴포넌트, 상호협력, 그리고 배치를 결정하는 것은 시스템 아키텍처(system architecture)의 예시를 보여준다.

<br>
<br>

### Centralized organizations

- 서버로부터 서비스를 요청하는 클라이언트 관점에서 생각하는 것은 이해하고 분산 시스템의 복잡성을 관리하는 데 도움이 된다.

<br>

### Simple client-server architecture

- client-server 모델에서 분산시스템의 프로세스는 2개의 그룹으로 나뉘어진다.
- **server**는 특정 서비스(ex. 파일 시스템 서비스나 데이터베이스 시스템)를 실행하는 프로세스이다.
- **client**는 서버로부터 서비스를 요청하는 프로세스이며, 서버의 응답을 기다린다.

![image](https://user-images.githubusercontent.com/78655692/149653998-894219e6-1806-49e8-a981-2964d8f99f57.png)

<br>

- 클라이언트와 서버 간의 통신은 간단한 무접속 프로토콜 수단에 의해 실행되는데, 밑에 있는 네트워크가 많은 LAN과 같이 상당히 신뢰할 때이다.
- 하지만, 프로토콜을 가끔 전송 실패에 대해 저항력있게 만드는 것은 사소하지 않다.
  - 우리가 할 수 있는 유일한 것은 응답 메시지가 안 들어온다면 클라이언트에게 요청을 재전송하는 것 뿐이다.
  - 하지만 클라이언트가 원본 요청 메시지를 잃어버리거나 응답의 전송 을 한지 안 한지 감지하지 못할 때 문제가 있다. 
  - 작동이 손상없이 여러번 반복되면, 이것을 **idempotent**라고 말한다.
- 대안으로, 많은 클라이언트-서버 시스템은 신뢰할 수 있는 연결 지향 프로토콜을 사용한다.
  - 이 해결책이 상대적으로 낮은 성능때문에 LAN에 적절하지 않을 지라도, 통신이 본래 신뢰할 수 없는 WAN에서는 완벽히 작동한다.
  - (가상적으로 모든 인터넷 애플리케이션 프로토콜은 신뢰할 수 있는 TCP/IP 연결에 기반한다.)

<br>
<br>

### Multitiered Architectures

- 가장 단순한 조직은 오직 두 가지의 기계를 가지고 있는 것이다.
  1. 유저 인터페이스 수준을 실행하는 프로그램만을 포함한 클라이언트 기계
  2. 프로세싱과 데이터 수준을 실행하는 프로그램을 포함한 서버 기계
- 조직에서 모든 것은 서버에서 다루는 반면, 클라이언트는 본질적으로 오직 편리한 그래픽 인터페이스만 가진 멍청한 터미널일 뿐이다.
  - 하지만 많은 다른 가능성들이 있다.
  - 많은 분산 애플리케이션들은 3 계층으로 나뉘어 진다. : user interface layer, processing layer, data layer

![image](https://user-images.githubusercontent.com/78655692/149660183-240e48df-3911-4436-86c8-e5a1d152173c.png)

<br>

- c의 예시로 워드 프로세서가 있다. 기본 편집기를 클라이언트(로컬에서 작동하거나 인메모리에서)쪽에서 실행하고, 서버쪽에서는 스펠링과 문법을 체크하는 고급 지원 기능들.
- 많은 클라이언트-서버 환경에서 d나 e는 특히 인기있다.
- 이런 조직들은 클라이언트 기계가 PC이거나 워크스테이션에서 사용된다. (네트워크를 통해 연결되어 분산 파일 시스템이나 데이터베이스로 가는) 
- 본질적으로 대부분의 애플리케이션은 클라이언트 기계에서 실행되지만, 파일이나 데이터베이스 entries의 모든 작동은 서버로 간다.

<br>

![image](https://user-images.githubusercontent.com/78655692/149660862-f7e3fc75-4f76-432a-88a3-5975869d1300.png)

- 위의 그림은 `three-tiered architecture`이다.
- 이 아키텍처에서 전통적으로 프로그램(처리 계층의 일부를 구성하는)들은 별개의 서버에 의해 실행되지만, 클라이언트와 서버 기계를 통해 부분적으로 추가로 배포될 수 있다.
- 분리된 프로세스(transaction processing monitor라 불리는) 다른 데이터 서버들을 통해 모든 트랜잭션들을 조정한다.
- 아주 다른 예시로, three-tiered architecture를 웹 사이트(Web site) 조직에서 볼 수 있다.
  - 웹 서버는 사이트의 엔트리 포인트로써 수행하며, 요청을 애플리케이션 서버(실제 처리가 발생하는)로 전달한다.
  - 이 애플리케이션 서버는 차례로 데이터베이스와 상호작용한다.

<br>
<br>

### Decentralized organizations: peer-to-peer systems

- 다른 층들은 직접적으로 애플리케이션의 논리적 조직으로 관계를 맺는다.
- 많은 비즈니스 환경에서, 분산 처리는 클라이언트-서버 애플리케이션을 다중 계층 구조(multitiered architecture)로 구성하는 것과 동등하다.
  - 이런 유형의 분포를 수직 분포(vertical distribution)이라 부른다.
  - 수직 분포의 특징은 다른 기계들에 논리적으로 다른 컴포넌트를 배치함으로써 얻는다.
- 시스템 관리 관점에서 수직 분포를 갖는 것은 도움이 된다.
  - 기능들이 다수의 기계들(각 기계는 특정 그룹의 기능들로 맞춰져 있다.)로부터 논리적이고 물리적으로 나뉘어져 있다.
- 현대 아키텍처에선, 가끔 클라이언트와 서버의 분포를 중요시하며, 이를 수평 분포(horizontal distribution)이라 한다.
  - 이런 유형의 분포에서, 클라이언트나 서버는 논리적으로 동등한 부분으로 물리적으로 분리될 수 있지만, 각 부분은 자체적인 공유 데이터 셋에서 작동한 다음
- 이 장에서는 수직 분산을 지원하는 현대 시스템 아키텍처의 한 분야인 `peer-to-peer systems`를 살펴볼 것이다.
  - **피어 (peer)** : 계층적 구조의 프로토콜을 사용하는 통신망의 동일 프로토콜 계층에서 대등한 지위로 동작하는 기능 단위 또는 장치 [^2]
  - cf) **노드 (node)** : 데이터를 전송하는 통로에 접속되는 하나 이상의 기능 또는 단위

<br>

- 높은 계층 관점에서, 프로세스들(p2p 시스템을 구성하는)은 모두 동일하다.
  - 수행이 필요한 기능들은 모든 프로세스(분산 시스템을 구성하는)에 의해 수행된다.
  - 결과적으로, 프로세스 간 상호작용은 대칭적이다.
  - 각 프로세스는 클라이언트와 서버로 동시에 수행할 것이다.(servant의 역할이기도 하다.) 
- peer-to-peer architecture $\rightarrow$ overlay network
  - 노드들은 프로세스에 의해 형성되고 링크들은 가능한 통신 채널을 표현하는 네트워크
  - 노드는 직접 통신하지 않고, 가능한 통신 채널을 통해 메시지를 보낸다.

<br>
<br>

### Structured peer-to-peer systems

- 정형 p2p 시스템에서 노드(=process)들은 오버레이(특정한 토폴로지를 고수하는: 링형, 트리형, 그리드형 등)를 구성한다.
  - 토폴로지는 데이터를 효과적으로 찾을 때 쓰인다.
- 이 시스템은 semantic-free index를 이용하는 것에 기반을 둔다.
  - 각 데이터 아이템(시스템에 의해 유지되는)은 특별하게 키와 연관되어 있고, 이 키는 결과적으로 인덱스로 쓰인다. 마지막에 가서, 해쉬 기능을 사용하는 것이 일반적이다.
  - 그래서 우리는 `key(data item) = hash(data item's value)`를 얻는다.
- p2p 시스템은 전반적으로 `(key, value)` 쌍을 담당한다.
  - 이 시스템은 분산 해쉬 테이블을 구현하고, DHT로 축약되었다.

<br>

- 시스템은 `lookup` 기능(키를 기존 노드에 map하는)의 효과적인 구현을 제공한다.
  - `existing node = lookup(key)`

<br>

![image](https://user-images.githubusercontent.com/78655692/150042920-f98d89fa-725e-4e77-83f8-4c7175eb7cd5.png)

<br>
<br>

### Unstructured peer-to-peer systems

- 비정형 p2p 시스템에서 각 노드는 이웃들의 애드혹 목록을 유지한다.
  - 결과 오버레이는 랜덤 그래프와 유사하다.
- 노드가 조인할때 종종 잘 알려진 노드와 접촉하여 시스템에 있는 다른 피어들의 시작 목록을 얻으려 한다.
  - 이 목록은 피어들을 찾는데 쓰이며, 다른 것들은 무시한다.
  - 실제로, 노드의 지역 목록은 수시로 변한다. 
- 비정형 P2P 시스템에서는 데이터 검색에 의존해야 한다.

<br>

1. **Flooding**

   - 발행 노드 u는 자료 아이템을 모든 이웃들에게 요청을 전달한다.
   - 수신 노드 v가 이전에 본적 있다면, 수신은 무시된다. 그렇지 않으면, v는 지역적으로 요청된 자료 아이템을 찾는다.
   - v가 필요한 자료를 가지고 있다면, 발행 노드에게 직접적으로 반응하거나 원래 전달자에게 반송한다.
   - 만약 v가 요청 자료를 가지고 있지 않다면, 요청을 이웃들 모두에게 전달한다.

2. **Random walks**

   - 발행 노드 u는 랜덤하게 선택된 이웃(ex. v)에게 요청하여 자료 아이템을 찾으려 할 것이다.
   - v가 만약 데이터를 갖고 있지 않다면, 이것은 요청을 랜덤하게 선택된 이웃에게 전달한다. 그 결과를 `random walk`라 한다.
   - 랜덤 워크는 네트워크 트래픽을 덜 부과하지만, 요청 데이터가 있는 노드에 도달하는 데 시간이 더 걸릴 수 있다.
   - 대기 시간을 줄이기 위해, 발행자는 n 랜덤 워크를 동시에 시작한다.

<br>

- `flooding`과 `random walks` 사이에는 policy-based search methods가 있다.

<br>
<br>

### Hierarchically organized peer-to-peer networks

- 비정형 P2P 시스템에서, 관련 자료 항목들을 찾는 것은 문제가 될 수 있다. (네트워크가 커짐에 따라; 확장성)
  - 검색 요청을 특정 자료 항목으로 보내는 결정론적 방법이 없다, 특히 노드가 의존하는 기술은 flooding이나 randomly walk 수단에 의한 요청을 위한 검색뿐이다.
- P2P 시스템의 대칭성을 버리는 게 실용적인 상황이 있다.
  - 노드들이 자원을 서로 제공하는 협력을 생각해본다.
  - CDN(; content delivery network)에서는, 노드들은 웹 클라이언트가 근처의 페이지를 접근하기 위해 웹 문서 복사본을 호스팅하기 위한 스토리지를 제공하기 때문에, 그들을 빨리 접근할 수 있다.
  - 필요한 것은 문서들이 어디에 저장되어야하는지를 찾는 수단이다.
  - 브로커(자료 사용량과 가용량에서 자료를 모으는(서로 가까이 있는 많은 수의 노드들에 대한))를 사용하는 것은 신속하게 노드(충분한 자원을 가진)를 선택할 수 있다. 
  - 인덱스를 유지하거나 브로커 역할을 하는 노드를 슈퍼 피어(super peer)라 한다.
    - 슈퍼 피어는 p2p 네트워크로 구성되어 계층적 구조로 이어진다.

<br>

![image](https://user-images.githubusercontent.com/78655692/150063109-a653a4bb-2e92-4b03-99e6-883b341b4194.png)

<br>

  - 약한 피어가 네트워크를 조인할 때마다, 슈퍼 피어에 붙게 되고 네트워크를 해제할 때까지 붙어 있는다.
  - 슈퍼 피어는 높은 가용성을 가진 수명이 긴 프로세스이다.

<br>

- 보았듯이, p2p 네트워크는 노드가 네트워크를 조인하고 해제하는 데 유연한 수단을 제공한다.
- 하지만, 슈퍼피어 네트워크(super-peer network)의 문제는 슈퍼피어에 적합한 노드를 어떻게 선택하느냐 이다.
  - `leader-election problem`이다.

<br>
<br>

## Hybrid Architectures

### Edge-server systems

- 엣지-서버 시스템은 서버가 네트워크의 엣지부분에 위치한 인터넷이 배치된다.
  - 엣지(edge)는 경계($\nearrow$기업 네트워크가 실제 인터넷 사이의)에 의해 형성된다.($\nearrow$ ISP; Internet Service Provider가 제공하는 것과 같이)
- 마찬가지로, 집에 있는 최종 사용자가 ISP를 통해 인터넷에 연결하면, ISP는 인터넷의 엣지에 거주할 것을 고려된다.

![image](https://user-images.githubusercontent.com/78655692/150065317-1c243864-e7aa-4c7f-a6a3-585566a396fb.png)

<br>

- 엣지 서버의 주요 목적은 내용을 제공(필터리를 적용하고 기능을 변환한 후에)하는 것이다.

<br>
<br>

### Collaborative distributed systems

- 비트토렌트(BitTorrent)는 p2p 파일 다운로드 시스템이다.
- 토렌트파일은(torrent file)은 특정 파일을 다운로드하는데 필요한 정보이다.
  - 특히, 이것은 링크($\nearrow$tracker로 알려진)($\nearrow$이것은 정확한 활동노드 계정($\nearrow$요청된 파일의 덩어리를 가지고 있는)을 지키는 서버이다.)를 포함한다.
    - 활동노드는 현재 파일을 다운로드하고 있는 것이다.

![image](https://user-images.githubusercontent.com/78655692/150066013-54e448a7-ac9d-43e4-b5b5-0819f9b7c1f3.png)

<br>
<br>

## 2.4 Example architectures

### The Netwrok File System

- 많은 분산 파일 시스템은 클라이언트-서버 구조로 구성된다.$\nearrow$ (클라이언트-서버 구조는) Network File System(NFS)를 가진 $\nearrow$ (NFS는) 유닉스 시스템에서 널리 배포된
- NFS의 주요 개념으로 각 파일 서버는 지역 파일 시스템의 표준 뷰를 제공하는 것이다.
  - 즉, 중요하지 않다. $\nearrow$ (어떤?) 로컬 파일 시스템이 어떻게 구현되는지는 
- NFS는 통신 프로토콜과 함께 제공된다. $\nearrow$ (통신 프로토콜은) 클라이언트를 서버에 있는 파일에 접속할 수 있게 해줌 (따라서 프로세스의 이종 집합을 허용함) $\nearrow$ (서버는) 다른 운영체제와 기계에서 실행되어 공통의 파일 시스템을 공유함
- NFS 모델과 비슷한 것으로 remote file service가 있다.
  - 이 모델에서 클라이언츠는 파일 시스템으로 가는 데 투명 접근을 제공받는다. $\nearrow$ (파일 시스템은) 원격 서버에 의해 관리됨
  - 클라이언츠는 파일의 실제 위치를 모른다. 대신에, 파일 시스템으로 가는 인터페이스를 제공받는다. $\nearrow$ (파일 시스템은) 기존 지역 파일 시스템에 의해 제공받는 인터페이스와 비슷함
  - 특히, 클라이언트는 오직 인터페이스를 제공받는다. $\nearrow$ (인터페이스는) 다양한 파일 작동을 포함한, 하지만 서버는 그러한 작동을 구현하는 것을 담당한다.
  - 이러한 모델을 `remote access model`이라 부른다. 

<br>

![image](https://user-images.githubusercontent.com/78655692/150070079-d20ccc45-973d-41d6-8400-177da852c6e4.png)

<br>

- 이와는 반대로, upload/download 모델에서는 클라이언트는 파일을 지역으로 접근한다. $\nearrow$ (언제?) 이것을 서버로부터 다운로드받은 후에
- 클라이언트가 파일받는 걸 끝낼때, 이것은 서버에 다시 업로드된다. $\nearrow$ (왜 다시?) 다른 클라이언트가 쓸 수 있도록

<br>

![image](https://user-images.githubusercontent.com/78655692/150070715-672de127-99c1-46c1-97c2-295c93e5b8ea.png)

<br>

- 사실상 모든 현대 유닉스 시스템에서, NFS는 위의 그림처럼 구현된다.
- 클라언트는 시스템 호출을 사용하여 파일 시스템에 접근한다.$\nearrow$ (시스템 호출은) 로컬 운영 체제에 의해 제공되는
- 하지만, 지역 유닉스 파일 시스템 인터페이스는 인터페이스가 Virtual File System(VFS)로 가면서 대체된다. $\nearrow$ (VFS란) 지금 사실상 다른 분산 파일 시스템으로 접속하는 데 표준이 됨
- 사실상, 모든 현재 운영 체제는 VFS를 제공하여 개발자에게 덜 강요하게 되었다. $\nearrow$ (어떤?) 운영 체제의 큰 부분을 재구현하는 데 $\nearrow$ (언제?) 새로운 파일시스템 구조를 적용할 때
- NFS와 함께, VFS 인터페이스에서의 작동은 지역 파일 시스템으로 전달되거나 분리된 컴포넌트(NFS 클라이언트로 알려진)로 전달된다. $\nearrow$ (NFS client란) 접근을 원격 서버에 저장된 파일로 가는 부분을 처리하는 걸 책임을 짐
- NFS에서, 모든 클라이언트-서버 통신은 remote procedure calls(RPCs)를 통해 행해진다.
  - RPC는 표준 방식이다. $\nearrow$ (어떤 방식?) 시스템 A에 있는 클라이언트가 정상적인 호출할 수 있도록 하는 $\nearrow$ (무엇을 정상적으로 호출?) 다른 시스템 B에서 구현되는 프로세스를
- NFS 클라이언트는 NFS 파일 시스템 작동을 구현한다. $\nearrow$ (무엇을 구현?) 서버로가는 원격 프로시저 호출로써
- NFS server는 들어오는 클라이언트 요청을 처리하는 걸 담당한다
  - 서버에 있는 RPC 컴포넌트는 들어오는 요청을 표준 VFS 파일 작동으로 전환한다. $\nearrow$ (표준 VFS 파일 작동이란) 나중에 VFS 계층을 통과하는
  - 다시 말해, VFS는 지역 파일 시스템을 구현하는 것을 담당한다 $\nearrow$ (지역 파일 시스템은 어떤 곳?) 실제 파일이 저장되어 있는
- 이 스키마의 중요한 이점은 NFS는 로컬 파일 시스템과 독립적이라는 것이다.

<br>
<br>

### The Web

### Simple Web-based systems

- 많은 웹기반 시스템은 여전히 구성되어 있다. $\nearrow$ (어떻게?) 상대적으로 단순한 클라이언트-서버 구조로 
- 웹사이트의 핵심은 프로세스에 의해 형성된다. $\nearrow$ (프로세스는) 문서들을 저장한 로컬 파일 시스템에 접근할 수 있는
  - 문서를 참조하는 가장 간단한 방식은 URL(uniform resource locator)이라 불리는 참조의 방식을 쓰는 것이다.
  - 이것은 문서를 어디에 위치할지를 지정한다. $\nearrow$ (어떻게 위치?) 파일 이름과 함께 관련된 서버의 DNS 이름을 임베딩함으로써 $\nearrow$ (파일 이름으로) 서버가 문서를 로컬 파일 시스템에서 찾을 수 있음
  - 게다가, URL은 애플리케이션 계층 프로토콜을 지정한다. $\nearrow$ (무엇을 위해) 네트워크를 통해 문서를 전달하는 걸
- 클라이언트는 브라우저를 통해 웹서버와 상호작용한다. $\nearrow$ (브라우저(brower)는) 문서를 적절하게 보여주는 걸 담당하는
- 브라우저와 웹서버 사이의 통신은 표준화되어 있다.: 그들은 모두 HyperText Transfer Protocol(HTTP)을 지킨다. 

<br>

![image](https://user-images.githubusercontent.com/78655692/150080128-9eb26f3e-43b1-48bc-87ce-0743c58f4d09.png)

<br>
<br>

### Multitiered architectures

![image](https://user-images.githubusercontent.com/78655692/150081163-7ae790a3-ea1d-4150-ba59-6313f0eb72d5.png)

- Figure 2.27과 같은 기본 아키텍처에서 첫번째 강화된 것 중 하나는 단순한 유저 인터랙션을 지원하는 것이다. $\nearrow$ (어떻게?) Common Gateway Interface(CGI) 수단에 의해
  - CGI는 웹 서버가 프로그램을 실행할 수 있는 표준방식이다. $\nearrow$ (프로그램은) 유저 데이터를 입력으로 가져오는
  - 보통 유저 데이터는 HTML 형식으로 가져온다.
  - 형식이 완료되면, 프로그램의 이름과 모은 파라미터 값들은 서버로 전송된다.
  - 데이터 처리 후, 프로그램은 HTML 문서를 생성하고 그 문서를 서버로 반환한다.
  - 서버는 그후 문서를 클라이언트에게 전달한다.

<br>

- 하지만 요즘 서버는 단순히 문서를 가져오는 것 이상으로 일한다.
  - 서버 또한 문서가 클라이언트에게 전달되기 전에 그것을 처리할 수 있다.
  - 특히, 문서가 server-side script를 포함한다면 $\nearrow$ (server-side script는) 서버에 의해 실행된다. $\nearrow$ (언제?) 문서가 지역적으로 가져올때
  - 다시 말해, server-side script를 사용하는 것은 문서를 변하게 한다. $\nearrow$ (어떻게) 스크립트를 실행결과로 바꿈으로써


<br>
<br>
<br>
<br>

## References

[^1]: [<용어> wrapper란? - peene](https://pinelover.tistory.com/187)
[^2]: [해시넷 - 피어](http://wiki.hash.kr/index.php/%ED%94%BC%EC%96%B4)