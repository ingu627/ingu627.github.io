---
layout: single
title: "분산 시스템(Distributed Systems) - 3. Processes"
excerpt: "Distributed Systems Third edition by Maarten van Steen,
Andrew S. Tanenbaum - cha3. Processes 3.1, 3.2, 3.3, 3.4"
categories: DS
tag : [DS]
toc: true
toc_sticky: true
sidebar_main: true

last_modified_at: 2022-01-27
---

<img align='right' width='200' height='200' src='https://user-images.githubusercontent.com/78655692/147719090-5f0942f1-1647-44ad-8d72-f11e3fe400d7.png
'>
본 글은 Distributed Systems 책의 내용을 개인 공부 목적을 위한 요약 및 정리한 내용입니다. <br> 번역보다는 직역을 통해 영문책을 이해하려다 보니 단어나 문장이 다소 어색할 수 있습니다. <br>  영어문장에 맞게 최대한 이해하려 했습니다. 가지치기($\nearrow$)로 꾸며주는 말을 따로 빼서 육하원칙, 지칭 등을 넣어 해석했습니다. <br>오타나 오류는 알려주시길 바라며, 도움이 되길 바랍니다.
{: .notice--info}

**글을 읽으면서 스스로에게 물어보기 <br><br> 1. 왜 만들어 졌을까?(background, def) <br> 2. 왜 필요할까? (why?) <br> 3. 장점과 단점은 무엇인가? (adv, disadv)**
{: .notice--danger}

<br>
<br>
<br>
<br>

## Chapter 3. PROCESSES

- 프로세스의 개념은 운영 체제 분야에서 기인한다. $\nearrow$ (운영 체제에서 프로세스 정의는) 실행 중인 프로그램.
- **스레드 (thread)**는 멀티코어와 멀티프로세서의 성능을 획득하는 데 역할을 할 뿐만 아니라, 클라이언트와 서버를 구축하는 데도 중요하다.
- 최근 몇년동안, 가상화의 개념은 다시 인기를 얻고 있다. **가상화**는 애플리케이션과 운영체제를 포함한 전체 환경을 다른 애플리케이션들과 동시에 실행하지만, 기본 하드웨어와 플랫폼과는 매우 독립적이어서, 이는 높은 수준의 이식성을 얻을 수 있다.
- 또한 **가상화**는 장애를 격리하는데 도움이 된다. $\nearrow$ (장애는) 에러나 보안 문제가 원인으로 인한
- 특히 광역 분산 시스템에서 중요한 문제는 다른 시스템 간에 프로세스를 이동하는 것이다.
- 프로세스 이동 또는 코드 이동은 확장성을 달성하는 데 도와줄 뿐 아니라, 동적으로 클라이언트와 서버를 구성할 수 있게 해준다.

<br>
<br>

## 3.1 Threads

- 프로세스들이 분산시스템에서 빌딩 블록을 형성할지라도, 관행상 나타내는데, 프로세스의 세분화 ($\nearrow$ (프로세스는) 분산시스템에서 구축된 운영체제에 의해 제공됨) 는 충분치 않다.
- 대신에, 드러났다 $\nearrow$ (뭐가?) 더 정교한 세분화를 갖는 것은 ($\nearrow$ (세분화는) 프로세스당 제어의 다중 스레드의 형성) 분산 애플리케이션을 구축하는 것과 더 나은 성능을 쉽게 얻을 수 있다는 것을
  - **프로세스 (process)** : 완전한 하나의 프로그램이 실행되고 있는 것
  - **스레드 (thread)** : 스레드는 프로세스와는 달리, 부모 프로세스 전체의 복사본을 만들지 않고, 필요한 코드 덩어리 만을 생성하여 동시에 수행 [^1]
  - 스레드는 하나의 프로세서 내에서 동시에 진행되는 작업들 (but, 작업 공간 X) [^5]

<br>
<br>

### Introduction to threads

- 프로그램을 실행하려면, 운영 체제는 많은 수의 가상 프로세서를 생성한다. $\nearrow$ (가상 프로세서의) 각 하나는 다른 프로그램을 실행하기 위한
- 이런 가상 프로세서를 추적하기 위해, 운영 체제는 **프로세스 테이블 (process table)**을 가지고 있다. $\nearrow$ (프로세스 테이블은) 저장하는 항목을 포함 $\nearrow$ (어떤 걸 저장?) CPU 레지스터 값들, 메모리 맵, 오픈 파일, 회계 정보, 특권 등등  
- 이런 항목은 **프로세스 컨텍스트 (process context)**을 형성한다.
  - **컨텍스트(=문맥) (context)** : 프로세서 안에 있는 레지스터, 플래그 등의 현재 값/상태들의 집합 (하드웨어 관점) <br> 그때그때 상황에 맞게끔, 실행/판단/결정 등을 해야하는 부분 (소프트웨어 관점) [^2]
- 프로세스 컨텍스트는 소프트웨어 아날로그로 본다. $\nearrow$ 하드웨어의 프로세서 컨텍스트의
  - 후자는 최소한의 정보로 구성되어 있다. $\nearrow$ (정보는) 하드웨어에 의해 자동으로 저장되는 $\nearrow$ (왜?) 인터럽트를 처리하기 위해, 그리고 나중에 CPU가 중지한 위치로 돌아간다.
- **프로세스 (process)**는 실행중인 프로그램으로 정의된다. $\nearrow$ (즉,) 현재 실행되는 $\nearrow$ (어디에) 운영체제의 가상 프로세서들 중 하나에
- 운영체제는 주의를 기울여야 한다. $\nearrow$ (어떤?) 독립적인 프로세스들이 악의적이나 부주의하게 서로 간의 행동의 정확성에 영향을 미치지 않도록
  - 즉, 다중 프로세스가 동시에 같은 CPU와 다른 하드웨어 리소스를 공유하는 사실은 투명하게 만들어야 한다.
  - 운영 체제는 하드웨어 지원을 요구로 한다. $\nearrow$ (어떤?) 이런 분리를 수행하려면
- 이러한 동시 투명성은 대가가 따른다.
- 운영 체제는 **MMU(; memory management unit)**의 레지스터를 수정해야 하고, **TLB(; translation lookaside buffer)**같은 주소 변환 캐시를 무효화해야 한다.
  - **메모리 관리 장치 (MMU)** : 가상 메모리 시스템을 관리하는 하드웨어 요소 [^3]
- 게다가 운영체제가 더 많은 프로세스를 지원한다면 $\nearrow$ (어떤 때보다?) 메인 메모리에서 동시에 유지할 수 있는 것보다, 메인 메모리와 디스크 간의 프로세스들을 바꿔야 한다. $\nearrow$ (언제?) 실제 스위칭이 일어나기 전에
- 프로세스처럼 스레드는 각 고유의 코드를 실행하지만, 어떠한 시도도 없다. $\nearrow$ (어떤?) 동시 투명성의 높은 수준을 달성하기 위한 $\nearrow$ (조건은) 성능 하락으로 이어진다면
  - 따라서, 스레드 시스템은 최소한의 정보만 유지한다. $\nearrow$ CPU를 몇몇 스레드에 의해 공유될 정도로만
- 스레드 컨텍스트는 프로세스 컨텍스트로만 구성된다. $\nearrow$ (~와 함께하는 건) 스레드 관리를 위한 다른 정보들
- 스레드 배치의 2가지 중요한 결과가 있다.
  1. 멀티스레드 애플리케이션의 성능은 단일 스레드 애플리케이션보다 나빠지는 걸 거의 볼 수 없다. (실제로, 멀티스레딩이 더 좋은 성능을 보인다.)
  2. 스레드는 프로세스 방식대로 자동으로 서로를 보호하지 않기 때문에, 다중 프로세스 애플리케이션의 개발은 더 지적인 노력이 필요하다.

<br>
<br>

### Thread usage in nondistributed systems

- 가장 중요한 이점은 이것으로부터 온다. $\nearrow$ 단일 스레드 프로세스에서,블록 시스템 호출이 실행될때마다, 전체 프로세스가 블록된다는 것이다.
  - **블록 시스템 호출 (blocking system call)** : 액션이 끝날때까지 무조건 기다려야 한다. (ex) read() 명령어)
- 멀티스레딩의 다른 이점으로는 병렬 처리를 이용하는 것이다. $\nearrow$ (언제?) 프로그램을 실행할 때 $\nearrow$ (on) 멀티프로세서나 멀티코어 시스템에서
- 병렬 처리를 위한 멀티스레딩은 날이갈수록 중요해지고 있다. $\nearrow$ (with) 상대적으로 싼 멀티프로세서와 멀티 코어 컴퓨터로 인해
- 멀티스레딩은 또한 유용하다 $\nearrow$ (in) 큰 애플리케이션 맥락에서 
- 프로그램 간 협력은 **IPC (프로세스 간 통신; interprocess communication)** 메커니즘에 의해 실행된다.
- IPC 메커니즘의 주요 결함은 통신이 상대적으로 광범위한 컨텍스트 스위칭을 필요로 한다는 것이다.

![image](https://user-images.githubusercontent.com/78655692/150777100-1e51ec70-97d1-4cf5-bc68-6446a407956f.png)

<br>

- 왜냐하면 IPC는 커널 중재를 필요로 하기 때문이다, 프로세스는 일반적으로 첫번째로 유저 모드에서 커널 모드로 바뀌어 질 것이다.
- 이것은 MMU의 메모리 맵을 바꿔야함을 요구한다, TLB도 마찬가지
- 부품 간 통신은 전적으로 공유 데이터를 사용함으로써 처리된다.

<br>
<br>

### Thread implementation

- 스레드 패키지 (thread package)는 스레드를 생성하고 파괴하는 동작을 포함한다. $\nearrow$ (도 또한) 동기화 변수에서의 작동도 $\nearrow$ (같은 것은) 뮤텍스와 조건 변수
- 스레드 패키지를 실행하기 위한 2가지 방식이 있다.
  1. 스레드 라이브러리를 구축하는 것이다. $\nearrow$ 전적으로 유저 공간에서 실행되는
  2. 커널이 스레드를 인지하고 그들을 스케줄링하는 것이다.
- **유저 수준 스레드 라이브러리 (user-level thread library)**는 많은 이점이 있다.
  1. 스레드를 생성하고 파괴하는 것은 싸다. $\nearrow$ (왜냐하면) 모든 스레드 관리는 유저 주소 공간에서 유지되기 때문, 스레드 생성의 가격은 결정된다 $\nearrow$ (뭐에) 메모리 할당을 위한 비용에 의해 $\nearrow$ (나아가서) 스레드 스택을 설정하기 위한
  2. 스레드 컨텍스트를 바꾸는 것은 몇 가지 명령만으로 할 수 있다.
     - 스레드 컨텍스트를 전환하는 것은 행해진다. $\nearrow$ (언제) 2 스레드가 동기화를 필요로 할때, 예를 들어 공유 데이터의 섹션에 들어올 때
     - 하지만, 컨텍스트 전환의 오버헤드의 대부분은 원인이 된다. $\nearrow$ 메모리 캐시를 동요시킴으로써
     - **오버헤드 (overhead)** : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말함 [^4]
- 유저 수준 스레드의 주요 결점은 기인한다 $\nearrow$ (어디서) 다대일 스레드 모델을 배치로부터
  - 블록 시스템의 호출은 전체 프로세스($\nearrow$ 스레드가 속한)를 즉시 블록하며, 다른 모든 스레드(그 프로세스에 속한)도 블록한다.
- **스레드**는 특히 유용하다 $\nearrow$ (어떨때) 애플리케이션을 부분으로 구축할 때 $\nearrow$ (부분들은) 논리적으로 동시에 실행됨
- 이런 문제들은 대부분 피한다. $\nearrow$ (영향은) 운영체제의 커널에 있는 스레드를 구축함으로써, 그래서 일대일 스레딩 모델이 된다. 
- 지불할 가격은 모든 스레드 동작은 커널에 의해 수행되어야 한다. $\nearrow$ (커널은) 시스템 호출을 필요로 하는
- 스레드 컨텍스트 전환은 프로세스 컨텍스트 전환만큼 비싸졌다.

<br>

- 스레드를 사용하는 것이 하나의 방식이라는 건 중요하다. $\nearrow$ (어떤 방식) 애플리케이션내에서 **동시** 실행을 구현하는
- 실제로, 애플리케이션은 동시 프로세스의 집합으로 구성되어, 공동으로 프로세스 간 시설을 사용한다. $\nearrow$ (시설은) 운영 체제에 의해 제공됨
  - 이런 접근의 좋은 예시는 아파치 웹 서버의 구조이다, 들어오는 요청을 처리하기 위한 약간의 프로세스로 시작하는
  - 각 프로세스는 서버의 단일 스레드 인스턴스를 형성하지만, 다른 인스턴스와 통신할 수 있다. $\nearrow$ (수단은) 표준 수단을 통해

<br>
<br>

### Threads in distributed systems

- 스레드의 중요한 특성으로, 스레드는 블록 시스템 호출을 허용하는 데 편리한 수단을 제공한다 $\nearrow$ (~없이) 스레드가 실행되고 있는 전체 프로세스를 차단하지 않고
- 이런 특성은 스레드가 분산시스템에서 사용하기에 좋다 $\nearrow$ (같은 것은) 쉽게 통신을 전달한다 $\nearrow$ (어떤 형태로) 동시에 다수의 논리적 연결을 유지하는 형태로

<br>
<br>

### Multithreaded clients

- 통신 지연을 숨기는 일반적인 방식은 통신을 개시하고 즉시 다른 것을 진행하는 것이다. 웹 브라우저에서 일어난다.
- 브라우저를 멀티스레드 클라이언트로 개발하면 문제가 상당히 단순해진다.
- 다른 중요한 이득으로 멀티스레드 웹 브라우저를 사용에 있다. $\nearrow$ (웹 브라우저의) 몇몇 연결들이 동시에 개방되는
- 멀티스레드 클라이언트를 사용할 때, 연결을 다른 복제품에 설정할 수 있다, 데이터를 병렬로 전달하는 것을 허용하여, 효과적으로 설정한다 $\nearrow$ (뭐를) 전체 웹 문서를 굉장히 짧은 시간안에 배포할 수 있는 것을 $\nearrow$ (비교급) 비복제 서버를 가진 것 보다
  - 이런 접근은 가능하다 $\nearrow$ (언제) 오직 클라이언트가 전적으로 들어오는 데이터의 병렬 스트림을 처리할 때만

<br>
<br>

### Multithreaded servers

- 실제로, 멀티스레드는 서버 코드를 상당히 단순화시킬 뿐 아니라, 쉽게 서버를 개발할 수 있다. $\nearrow$ (서버는) 고성능을 달성하기 위해 병렬을 이용함
- 한 스레드(=**dispatcher**)는 파일 동작을 위해 들어오는 요청을 읽는다.
  - cf. **인터럽트 (interrupt)** : 어떤 장치가 다른 장치의 일을 잠시 중단시키고 자신의 상태 변화를 알려주는 것

<img src='https://user-images.githubusercontent.com/78655692/151277316-e29cf852-df78-4783-831a-722e45ad6599.png' width=400> [^6]

<br>

- 요청을 검수하면, 서버는 worker thread를 고르고, 이것에게 요청을 처리한다.
- 워커는 로컬 파일 시스템에 있는 블록 읽기를 수행함으로써 진행되고, 이는 스레드가 데이터가 디스크로부터 불러와야 중단된다.
- 스레드가 중단되면, 다른 스레드를 실행시킨다.

![image](https://user-images.githubusercontent.com/78655692/151277468-3e64f629-3f5b-4067-b660-bea52f7e73c1.png)

<br>

- 파일 서버를 단일 스레드로 동작한다고 본다면?
  - 파일 서버의 메인 루프는 요청을 받고, 검수하고, 수행되어 완성되고 다른 것을 받는다.
  - 기다리는 동안, 서버는 유후 상태이고 다른 요청을 실행할 수 없다.
  - 게다가, 파일 서버가 전용 기계에서 실행되면, CPU는 유후 상태가 된다. $\nearrow$ (동시에) 파일 서버가 디스크를 기다리는 동안
  - 요청 수가 훨씬 적다 $\nearrow$ (요청은) 시간 당 처리할 수 있는
  - 따라서, 스레드는 상당한 성능을 얻지만 각 스레드는 순차적으로 프로그램된다.
 
![image](https://user-images.githubusercontent.com/78655692/151281598-e70c7c31-0a39-4335-b7bc-6a9e73589467.png)

- **parallelism** $\approx$ **performance**
- **blocking system** $\approx$ **programming** 

<br>

- 다중 프로세스를 쓸 때는 공유 데이터에 사고를 예방 가능
  - 프로세스가 통신이 많아지면, 성능 하락 (스레드에 비해)

<br>
<br>

## 3.2 Virtualization

- 








<br>
<br>
<br>
<br>

## References

[^1]: [정보통신기술용어해설 - Thread   스레드, 쓰레드 ](http://www.ktword.co.kr/test/view/view.php?nav=2&no=2299&sh=%EC%8A%A4%EB%A0%88%EB%93%9C)
[^2]: [정보통신기술용어해설 - Context   컨텍스트, 상황 (Context)](http://www.ktword.co.kr/test/view/view.php?nav=2&no=2668&sh=processor+context)
[^3]: [정보통신기술용어해설 - MMU   Memory Management Unit   메모리 관리 장치](http://www.ktword.co.kr/test/view/view.php?nav=2&no=2664&sh=mmu)
[^4]: [위키백과 - 오버헤드](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C)
[^5]: [프로세스(Process)와 스레드(Thread) - gil0127.log](https://velog.io/@gil0127/%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9CSingle-thread-vs-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-Multi-thread)
[^6]: [인터럽트(Interrupt)란? 그리고 디스패처(Dispatcher)란? - Crocus](https://www.crocus.co.kr/1406) []]





