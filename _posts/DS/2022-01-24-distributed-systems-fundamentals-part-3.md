---
layout: single
title: "분산 시스템 3장: 프로세스 모델·스레드·가상화와 통신 기초"
excerpt: "Distributed Systems Third edition by Maarten van Steen,
Andrew S. Tanenbaum - cha3. Processes 3.1, 3.2, 3.3, 3.4"
categories: DS
tags: [DS]
toc: true
toc_sticky: true
sidebar_main: false

last_modified_at: 2023-04-25
---

<img align='right' width='200' height='200' src='https://user-images.githubusercontent.com/78655692/147719090-5f0942f1-1647-44ad-8d72-f11e3fe400d7.png
'>
본 글은 Distributed Systems 책의 내용을 개인 공부 목적을 위한 요약 및 정리한 내용입니다. <br> 오타나 오류는 알려주시길 바라며, 도움이 되길 바랍니다. <br><br> **2022.02.02 Update** <br> **2023.04.25 Update**
{: .notice--info}

**글을 읽으면서 스스로에게 물어보기 <br><br> 1. 왜 만들어 졌을까?(background, def) <br> 2. 왜 필요할까? (why?) <br> 3. 장점과 단점은 무엇인가? (adv, disadv)**
{: .notice--danger}

<br>
<br>
<br>
<br>

## Chapter 3. PROCESSES

- 운영 체제에서 **프로세스(process)** 정의는 실행 중인 프로그램을 뜻한다.
- **스레드(thread)**는 멀티코어와 멀티프로세서의 성능을 획득하는 데 역할을 할 뿐만 아니라, 클라이언트와 서버를 구축하는 데도 중요하다.
- 최근 몇년동안, 가상화의 개념은 다시 인기를 얻고 있다. **가상화**는 애플리케이션과 운영체제를 포함한 전체 환경을 다른 애플리케이션들과 동시에 실행하지만, 기본 하드웨어와 플랫폼과는 매우 독립적이어서, 이는 높은 수준의 이식성을 얻을 수 있다.
  - **플랫폼 (platform)** : 소프트웨어를 개발하고 실행하는 기반환경 [^7]
- 또한 **가상화**는 에러나 보안 문제가 원인으로 인한 장애를 격리하는데 도움이 된다.  
- 특히 광역 분산 시스템에서 중요한 문제는 다른 시스템 간에 프로세스를 이동하는 것이다.
- 프로세스 이동 또는 코드 이동은 확장성을 달성하는 데 도와줄 뿐 아니라, 동적으로 클라이언트와 서버를 구성할 수 있게 해준다.

<br>
<br>

## 3.1 Threads

- 프로세스들이 분산시스템에서 빌딩 블록을 형성할지라도, 분산시스템에서 구축된 운영체제에 의해 제공되기 때문에 프로세스의 세분화가 충분치 않다.
- 대신에 더 정교하게 세분화를 할 수 있는 스레드가 나타났다. 
  - **프로세스 (process)** : 완전한 하나의 프로그램이 실행되고 있는 것
  - **스레드 (thread)** : 스레드는 프로세스와는 달리, 부모 프로세스 전체의 복사본을 만들지 않고, 필요한 코드 덩어리 만을 생성하여 동시에 수행 [^1]
    - 스레드는 하나의 프로세서 내에서 동시에 진행되는 작업들을 말한다. (but, 작업 공간 X) [^5]

<br>
<br>

### Introduction to threads

- 프로그램을 실행하려면, 운영 체제는 각 하나당 다른 프로그램을 실행하기 위한 많은 수의 가상 프로세서를 생성한다.  
- 이런 가상 프로세서를 추적하기 위해, 운영 체제는 CPU 레지스터 값들, 메모리 맵, 오픈 파일, 회계 정보, 특권 등등을 저장하는 항목을 포함하고 있는 **프로세스 테이블 (process table)**을 가지고 있다.   
- 이런 항목은 **프로세스 컨텍스트 (process context)**을 형성한다.
  - **컨텍스트(=문맥) (context)** : 프로세서 안에 있는 레지스터, 플래그 등의 현재 값/상태들의 집합 (하드웨어 관점) 
    - 그때그때 상황에 맞게끔, 실행/판단/결정 등을 해야하는 부분 (소프트웨어 관점) [^2]
- 프로세스 컨텍스트는 하드웨어의 프로세서 컨텍스트의 소프트웨어 아날로그로 본다.  
  - 인터럽트를 처리하기 위해 후자는 하드웨어에 의해 자동으로 저장되는 최소한의 정보로 구성되어 있다. 그리고 나중에 CPU가 중지한 위치로 돌아간다.
- **프로세스 (process)**는 실행중인 프로그램으로 정의된다.
- 운영체제는 독립적인 프로세스들이 악의적이나 부주의하게 서로 간의 행동의 정확성에 영향을 미치지 않도록 주의를 기울여야 한다. 
  - 즉, 다중 프로세스가 동시에 같은 CPU와 다른 하드웨어 리소스를 공유하는 사실은 투명하게 만들어야 한다.
  - 이런 분리를 수행하려면 운영 체제는 하드웨어 지원을 요구로 한다.  
- 이러한 동시 투명성은 대가가 따른다.
- 운영 체제는 **MMU(; memory management unit)**의 레지스터를 수정해야 하고, **TLB(; translation lookaside buffer)**같은 주소 변환 캐시를 무효화해야 한다.
  - **메모리 관리 장치 (MMU)** : 가상 메모리 시스템을 관리하는 하드웨어 요소 [^3]
- 게다가 운영체제가 더 많은 프로세스를 지원한다면 실제 스위칭이 일어나기 전에 메인 메모리에서 동시에 유지할 수 있는 것보다 메인 메모리와 디스크 간의 프로세스들을 바꿔야 한다. 
- 프로세스처럼 스레드는 각 고유의 코드를 실행하지만, 성능 하락으로 이어진다면 동시 투명성의 높은 수준을 달성하기 위한 어떠한 시도도 없다. 
  - 따라서, 스레드 시스템은 CPU를 몇몇 스레드에 의해 공유될 정도로만 최소한의 정보만 유지한다.  
- 스레드 컨텍스트는 스레드 관리를 위한 다른 정보들과 프로세스 컨텍스트로만 구성된다.  
- 스레드 배치의 2가지 중요한 결과가 있다.
  1. 멀티스레드 애플리케이션의 성능은 단일 스레드 애플리케이션보다 나빠지는 걸 거의 볼 수 없다. (실제로, 멀티스레딩이 더 좋은 성능을 보인다.)
  2. 스레드는 프로세스 방식대로 자동으로 서로를 보호하지 않기 때문에, 다중 프로세스 애플리케이션의 개발은 더 지적인 노력이 필요하다.

<br>
<br>

### Thread usage in nondistributed systems

- 가장 중요한 이점은 단일 스레드 프로세스에서, 블록 시스템 호출이 실행될때마다 전체 프로세스가 블록된다는 것으로부터 온다. 
  - **블록 시스템 호출 (blocking system call)** : 액션이 끝날때까지 무조건 기다려야 한다. (예. read() 명령어)
- 멀티스레딩의 다른 이점으로는 멀티프로세서나 멀티코어 시스템에서 프로그램을 실행할 때 병렬 처리를 이용하는 것이다.  
- 상대적으로 싼 멀티프로세서와 멀티 코어 컴퓨터로 인해 병렬 처리를 위한 멀티스레딩은 날이갈수록 중요해지고 있다.
- 프로그램 간 협력은 **IPC (프로세스 간 통신; interprocess communication)** 메커니즘에 의해 실행된다.
- IPC 메커니즘의 주요 결함은 통신이 상대적으로 광범위한 컨텍스트 스위칭을 필요로 한다는 것이다.

![image](https://user-images.githubusercontent.com/78655692/150777100-1e51ec70-97d1-4cf5-bc68-6446a407956f.png)

<br>

- 왜냐하면 IPC는 커널 중재를 필요로 하기 때문이다, 프로세스는 일반적으로 첫번째로 유저 모드에서 커널 모드로 바뀌어 질 것이다.
- 이것은 MMU의 메모리 맵을 바꿔야함을 요구한다. (TLB도 마찬가지)
- 부품 간 통신은 전적으로 공유 데이터를 사용함으로써 처리된다.

<br>
<br>

### Thread implementation

- 스레드 패키지 (thread package)는 뮤텍스와 조건 변수같은 동기화 변수에서의 작동과 스레드를 생성하고 파괴하는 동작을 포함한다.  
- 스레드 패키지를 실행하기 위한 2가지 방식이 있다.
  1. 전적으로 유저 공간에서 실행되는 스레드 라이브러리를 구축하는 것이다.  
  2. 커널이 스레드를 인지하고 그들을 스케줄링하는 것이다.
- **유저 수준 스레드 라이브러리 (user-level thread library)**는 많은 이점이 있다.
  1. 모든 스레드 관리는 유저 주소 공간에서 유지되기 때문에 스레드를 생성하고 파괴하는 것은 싸다. 
     - 스레드 생성의 가격은 스레드 스택을 설정하기 위한 메모리 할당을 위한 비용에 의해 결정된다. 
  2. 스레드 컨텍스트를 바꾸는 것은 몇 가지 명령만으로 할 수 있다.
     - 공유 데이터의 섹션에 들어올 때 스레드가 동기화를 필요로 할때 스레드 컨텍스트를 전환하는 것은 행해진다.  
     - 하지만, 컨텍스트 전환의 오버헤드의 대부분은 메모리 캐시를 동요시킴으로써 원인이 된다. 
     - **오버헤드 (overhead)** : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말함 [^4]
- 유저 수준 스레드의 주요 결점은 다대일 스레드 모델을 배치로부터 기인한다. 
  - 블록 시스템의 호출은 스레드가 속한 전체 프로세스를 즉시 블록하며, 그 프로세스에 속한 다른 모든 스레드도 블록한다.
- **스레드**는 애플리케이션을 논리적으로 동시에 실행되는 부분으로 구축할 때 특히 유용하다. 
- 이런 문제들은 운영체제의 커널에 있는 스레드를 구축함으로써 대부분 피한다. 
- 지불할 가격은 모든 스레드 동작은 시스템 호출을 필요로 하는 커널에 의해 수행되어야 한다.  
- 스레드 컨텍스트 전환은 프로세스 컨텍스트 전환만큼 비싸졌다.

<br>

- 스레드를 사용하는 것이 애플리케이션내에서 **동시** 실행을 구현하는 방식이라는 건 중요하다.  
- 실제로, 애플리케이션은 동시 프로세스의 집합으로 구성되어, 공동으로 프로세스 간 시설을 사용한다. 
  - 이런 접근의 좋은 예시는 들어오는 요청을 처리하기 위한 약간의 프로세스로 시작하는 아파치 웹 서버의 구조이다.
  - 각 프로세스는 서버의 단일 스레드 인스턴스를 형성하지만, 다른 인스턴스와 통신할 수 있다. 

<br>
<br>

### Threads in distributed systems

- 스레드의 중요한 특성으로, 스레드는 블록 시스템 호출을 허용하는 데 스레드가 실행되고 있는 전체 프로세스를 차단하지 않고 편리한 수단을 제공한다.  
- 이런 특성은 스레드가 분산시스템에서 동시에 다수의 논리적 연결을 유지하는 형태로 쉽게 통신을 전달할 때 사용하기 좋다.  

<br>
<br>

### Multithreaded clients

- 통신 지연을 숨기는 일반적인 방식은 통신을 개시하고 즉시 다른 것을 진행하는 것이다. 웹 브라우저에서 일어난다.
- 브라우저를 멀티스레드 클라이언트로 개발하면 문제가 상당히 단순해진다.
- 다른 중요한 이득으로 몇몇 연결들이 동시에 개방하는 멀티스레드 웹 브라우저를 사용에 있다.

<br>
<br>

### Multithreaded servers

- 실제로, 멀티스레드는 서버 코드를 상당히 단순화시킬 뿐 아니라, 쉽게 고성능을 달성하기 위해 병렬을 이용할 수 있는 서버를 개발할 수 있다.
- 한 스레드(=**dispatcher**)는 파일 동작을 위해 들어오는 요청을 읽는다.
  - cf. **인터럽트 (interrupt)** : 어떤 장치가 다른 장치의 일을 잠시 중단시키고 자신의 상태 변화를 알려주는 것

<img src='https://user-images.githubusercontent.com/78655692/151277316-e29cf852-df78-4783-831a-722e45ad6599.png' width=400> [^6]

<br>

- 요청을 검수하면, 서버는 worker thread를 고르고, 이것에게 요청을 처리한다.
- 워커는 로컬 파일 시스템에 있는 블록 읽기를 수행함으로써 진행되고, 이는 스레드가 데이터가 디스크로부터 불러와야 중단된다.
- 스레드가 중단되면, 다른 스레드를 실행시킨다.

![image](https://user-images.githubusercontent.com/78655692/151277468-3e64f629-3f5b-4067-b660-bea52f7e73c1.png)

<br>

- 파일 서버를 단일 스레드로 동작한다고 본다면?
  - 파일 서버의 메인 루프는 요청을 받고, 검수하고, 수행되어 완성되고 다른 것을 받는다.
  - 기다리는 동안, 서버는 유후 상태이고 다른 요청을 실행할 수 없다.
  - 게다가, 파일 서버가 전용 기계에서 실행되면, 파일 서버가 디스크를 기다리는 동안 CPU는 유후 상태가 된다. 
  - 시간 당 처리할 수 있는 요청 수가 훨씬 적다.  
  - 따라서, 스레드는 상당한 성능을 얻지만 각 스레드는 순차적으로 프로그램된다.
 
![image](https://user-images.githubusercontent.com/78655692/151281598-e70c7c31-0a39-4335-b7bc-6a9e73589467.png)

- **parallelism** $\approx$ **performance**
- **blocking system** $\approx$ **programming** 

<br>

- 다중 프로세스를 쓸 때는 공유 데이터에 사고를 예방 가능하다.
  - 프로세스가 통신이 많아지면, 스레드에 비해 성능 하락한다.

<br>
<br>

## 3.2 Virtualization

- 스레드와 프로세스는 동시에 더 많은 것들을 보이게 하는 방법이다.  
- 스레드와 프로세스 사이를 빠르게 전환함으로써, 병렬의 환상이 생성된다.
- 단일 CPU와 더 많이 있어 보이는 "척" 하는 분리는 다른 리소스들로 확장되었다. (이것을 **resource virtualization**라 한다.)

<br>
<br>

### Principle of virtualization

- 모든 분산 컴퓨터 시스템은 프로그래밍 인터페이스를 높은 수준의 인터페이스에 제공한다.
- **가상화 (virtualization)**는 다른 시스템의 행동을 흉내내기 위해 기존 인터페이스를 확장하거나 대체를 처리한다. 

![image](https://user-images.githubusercontent.com/78655692/151499349-f69ad3e8-6534-4402-9f0d-2217f2ca226f.png)

<br>
<br>

### Virtualization nad distributed systems

- 1990년대에 이르러, 하드웨어와 낮은 수준의 시스템(소프트웨어가 빠르게 변한, 높은 수준의 추상화의 소프트웨어)이 안정적으로 되고 있다.
  - 즉, 지금 레거시 소프트웨어는 의존하는 플랫폼과 같은 속도로 유지되지 못할 상황에 처해 있다.  
  - 가상화는 이것을 레거시 인터페이스를 새로운 플랫폼으로 복사함으로써, 그리고 그 플랫폼을 기존 프로그램의 큰 클래스를 위해 즉시 개방으로써 도와준다.   
- 또 중요한 것으로, 네트워킹은 완전히 퍼베이시브 되었다.




<br>
<br>
<br>
<br>

## References

[^1]: [정보통신기술용어해설 - Thread   스레드, 쓰레드 ](http://www.ktword.co.kr/test/view/view.php?nav=2&no=2299&sh=%EC%8A%A4%EB%A0%88%EB%93%9C)
[^2]: [정보통신기술용어해설 - Context   컨텍스트, 상황 (Context)](http://www.ktword.co.kr/test/view/view.php?nav=2&no=2668&sh=processor+context)
[^3]: [정보통신기술용어해설 - MMU   Memory Management Unit   메모리 관리 장치](http://www.ktword.co.kr/test/view/view.php?nav=2&no=2664&sh=mmu)
[^4]: [위키백과 - 오버헤드](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C)
[^5]: [프로세스(Process)와 스레드(Thread) - gil0127.log](https://velog.io/@gil0127/%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9CSingle-thread-vs-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-Multi-thread)
[^6]: [인터럽트(Interrupt)란? 그리고 디스패처(Dispatcher)란? - Crocus](https://www.crocus.co.kr/1406)
[^7]: [정보통신기술용어해설 - Platform   플랫폼](http://www.ktword.co.kr/test/view/view.php?nav=2&no=3553&sh=%ED%94%8C%EB%9E%AB%ED%8F%BC)
